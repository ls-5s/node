基本类型
number string Boolean undefined null symbol
10 01 0x1

Array object function
const add = (a:number,b:number) => {
    return a+b
}
基础数据类型存储到栈里面

基础数据类型为什么存在栈里面
基础数据的特点是值的大小固定，生命周期短
而栈的优势是读取迅速，空间分配紧凑

一个变量对应栈里的一块独立空间。

执行 let a = 10：栈中创建「变量名 + 值」的独立空间

1.分配一块小小的空间
2.在这个空间中，同时存储a 10 形成 [a -> 10] 的直接映射

执行 let b = a：栈中新建空间，拷贝「a 的值」而非共享
这一步是关键 —— 赋值操作时，引擎会判断 a 是基本类型，所以会：

在栈内存中新分配一块独立空间（比如地址 0x002）；
把 a 对应的值（10）完整拷贝一份，存入 0x002 空间，并绑定变量名 b。

注意：这里拷贝的是「值」，不是「地址」——a 对应 0x001，b 对应 0x002，两块空间完全独立，只是里面存的值暂时都是 10。

引用类型为什么栈存地址、堆存对象内容？

引用类型 结构复杂，大小不固定
堆的特点是 空间大，可以动态分配
栈内存中存储指向堆内存中对象的引用地址（类似指针），堆内存中存储对象的具体内容。
执行 var obj = {}
在堆内，开辟一块空间，存储对象的具体内容 地址
在栈内，开辟一块空间，存储对象的地址

栈内存地址	变量名	存储内容
0x001	obj1	0x1000 （堆地址）



堆内存：

堆内存地址	存储内容
0x1000	{}

复制引用地址：把 obj1 在栈内存中存储的堆内存地址 0x1000 复制一份，存入 obj2 对应的栈空间。这意味着 obj2 也指向了堆内存中地址为 0x1000 的那个空对象，此时 obj1 和 obj2 共享同一个堆内存中的对象。

此时内存状态如下：
栈内存：

栈内存地址	变量名	存储内容
0x001	obj1	0x1000 （堆地址）
0x002	obj2	0x1000 （堆地址）

堆内存：

堆内存地址	存储内容
0x1000	{}


# 数组的常用方法
1.操作方法
增:push unshift(改变数据长度)
删:pop shift(改变数组长度)
改:splice(详细看)
查:indexOf find includes
indexOf 放回 -1 includes true
find
2.排序方法 
sort reverse()(会改变原数组)
list.sort((a,b)=> a - b)

返回 负数：a 排在 b 前面（a 比 b 小）；
返回 正数：b 排在 a 前面（a 比 b 大）；
返回 0：a 和 b 位置不变。

会修改原数组：如果不想改变原数组，需要先复制一份再排序，比如用 [...arr].sort() 或 arr.slice().sort()：
javascript
运行
const nums = [10, 2, 25, 5];
const sortedNums = [...nums].sort((a, b) => a - b); // 复制后排序
console.log(nums); // 原数组不变：[10, 2, 25, 5]
console.log(sortedNums); // 新数组排序后：[2, 5, 10, 25]

3.转换方法
join()
let colors = ["red", "green", "blue"];
// 传逗号作为分隔符，元素之间用逗号连起来
alert(colors.join(",")); // 输出 "red,green,blue"
// 传"||"作为分隔符，元素之间用双竖线连起来
alert(colors.join("||")); // 输出 "red||green||blue"
4.迭代方法
every()
some()
forEach()
filter()
map()

# 类型转换
显示转换(将一种数据类型的值转换为另一种数据类型的值的过程)
string number boolean parselnt
number 和 parselnt 的区别
隐性转换
隐式转换是指在特定的运算或操作场景下，JavaScript 引擎自动将一种数据类型的值转换为另一种数据类型的值的过程


# 说说var、let、const之间的区别
# 面试官：你是怎么理解ES6新增Set、Map两种数据结构的？

set 是e6 新增的数据结构，类似于数据，是来去重的，
add delete has() clear
keys values 

# 面试官：说说你对事件循环的理解

# 面试官：你是怎么理解ES6中 Promise的？使用场景？

他是解释回调地狱的问题，他的优点是代码的可读性增强，
链式操作，减低了编码难度
它有三种状态，pending fulfilled rejected
一旦状态改变，就不会再变，

使用
const promise = new Promise((resolve,reject)=> {

}).then(){

}.catch(()=> {

}).finally(()=> {
    console.log('finally')
})
使用场景
# 面试官：说说你对闭包的理解？闭包使用场景
“我理解的闭包，本质是 JavaScript 词法作用域的自然结果 —— 简单说就是‘内层函数能引用外层函数的变量，即使外层函数执行完’。
它的核心特征是‘内层函数 + 外层变量’：比如外层函数里有个 count 或 a，内层函数引用了这个变量，当外层函数执行完成后，这个变量不会被垃圾回收，因为内层函数还在引用它（比如柯里化函数里，currying(1) 执行完后，a=1 被后续的 (b)=>{...} 引用，所以能保留）。

闭包的使用场景，核心离不开两点：一是创建私有变量，二是延长变量生命周期。
比如柯里化函数，像 currying 把 add 的 3 个参数拆分成 3 个单参数函数，add1 = currying(1) 固定 a=1 后，后续调用不用再传 a，这就是靠闭包延长 a 的生命周期、实现参数复用；
还有模拟私有变量，比如封装计数器模块，让 count 只能被内部方法修改，外部拿不到，避免全局污染；
另外循环绑定事件时，用闭包保存每次循环的索引，避免所有按钮点击拿到相同值，这也是延长变量生命周期的用法。

不过要注意，闭包会让变量长期占内存，滥用可能导致内存泄漏，所以不用的闭包要手动清理引用，比如解除事件绑定、清空定时器。”
总结

# 面试官：说说你对Node.js 的理解？优缺点？应用场景？
他是服务器端，事件驱动，非阻塞式I/O的、 js 的运行环境
“本质是让 JS 跳出浏览器，能在服务器 / 本地环境操作文件、处理网络请求的工具

事件驱动就是当进来一个新的请求的时，请求将会被压入一个事件队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数
比如补充：“传统服务器处理 1000 个请求要开 1000 个线程，容易占满内存；而 Node.js 用一个主线程 + 事件循环，把请求压入队列，只在‘事件就绪’（比如文件读完）时执行回调，不用空等 I/O，所以能高效处理高并发。”

比如读取一个文件，文件读取完毕后，就会触发对应的状态，然后通过对应的回调函数来进行处理

优点
处理高并发场景性能更佳
适合I/O密集型应用，值的是应用在运行极限时，CPU占用率仍然比较低，大部分时间是在做 I/O硬盘内存读写操作解释下
缺点
不适合CPU密集型应用
只支持单核CPU，不能充分利用CPU
可靠性低，一旦代码某个环节崩溃，整个系统都崩溃

善于I/O，不善于计算。因为Nodejs是一个单线程，如果计算（同步）太多，则会阻塞这个线程
大量并发的I/O，应用程序内部并不需要进行非常复杂的处理

第一大类：用户表单收集系统、后台管理系统、实时交互系统、考试系统、联网软件、高并发量的web应用程序
第二大类：基于web、canvas等多人联网游戏
第三大类：基于web的多人实时聊天客户端、聊天室、图文直播
第四大类：单页面浏览器应用程序
第五大类：操作数据库、为前端和移动端提供基于json的API

不适合 CPU 密集：可以把计算任务交给 Java/Python 服务（比如用 Node.js 接请求，转发给 Python 算数据，算完再返回）；
单核问题：用 “集群模式” 开多个 Node.js 进程，利用多核 CPU（比如 8 核服务器开 8 个进程）；
可靠性低：用 PM2 工具做进程守护（崩溃自动重启），再用 try/catch 捕获异常，避免单线程崩溃。

# 面试官：说说你对正则表达式的理解？应用场景？
“正则表达式是一种文本模式匹配工具，核心是用预定义语法描述‘想要匹配的字符串格式’，在 JS 中是 RegExp 对象，主要用于查找、替换、提取、校验文本。

首先，创建方式有两种：

字面量 /(模式)/(修饰符)，比如 /\d+/g，适合模式固定，无需转义 \；
构造函数 new RegExp(模式字符串, 修饰符)，适合动态模式，注意 \ 要转义为 \\，比如 new RegExp('\\d+', 'g')。

然后是核心匹配规则，按功能分：

定位符 ^（开头）、$（结尾），比如 QQ 校验 ^[1-9]\d{4,14}$ 确保整串符合；
元字符 \d（数字）、\w（字母 / 数字 / 下划线）、.（任意字符，除换行）；
量词 *（0 + 次）、+（1 + 次）、{n,m}（n~m 次），加 ? 变成懒惰模式，比如 \d+? 优先少匹配；
字符集 [a-z]（小写字母）、[^0-9]（非数字）。

常用方法分两类：

正则方法：test 返布尔值（校验）、exec 返匹配细节（带分组）；
字符串方法：match 获匹配结果、replace 替换内容（支持引用分组）、split 按规则分割。

应用场景最常见的是表单校验（QQ、账号、邮箱），还有文本提取（提数字、域名）、替换（隐藏手机号）、分割（按标点分句子）。

比如账号校验 ^[a-zA-Z]([a-zA-Z0-9]|[_.)]){4,19}$，确保 5~20 位、字母开头；手机号校验 ^1[3-9]\d{9}$，确保 11 位且符合 

另外要注意贪婪和懒惰模式的差异，还有修饰符 g（全局）、i（不区分大小写）、s（. 匹配换行）的使用，以及性能优化，比如模式固定用字面量。”
总结
你的原始回答已经覆盖了核心点，优化后主要解决了 “表述简略→详细准确”“逻辑零散→层层递进”“案例单一→场景拓展” 的问题，同时补充了面试中容易加分的 “深度细节”（如贪婪 / 懒惰、修饰符、性能），能让面试官感受到你对正则的理解不仅是 “记住规则”，更是 “会用、懂原理”。
# 面试官：说说Git中 fork, clone,branch这三个概念，有什么区别?

# 说说对git pull 和 git fetch 的理解？有什么区别？
# 面试官：说说你对slot的理解？slot使用场景有哪些？
他是在封装一个组件，然后在组件中定义一个插槽，插槽的内容是组件的子元素，组件的子元素可以是任意的元素，包括组件、元素、文本等
分类：
默认插槽
具名插槽
作用域插槽
使用场景
卡片组件
表格，弹窗，对话框，提示框，加载中等

原理分析
简单说，slot（插槽）的原理就是「父子组件配合搞内容定制」，核心就3步，特别好懂：

1. **子组件先“留位置”**：  
子组件里写 `<slot>` 标签，相当于在自己的结构里“挖个坑”，还能给这个坑起名字（比如 `<slot name="header">`），甚至留好“备用内容”（坑里面写的东西，父组件没填就显示这个）。

2. **父组件再“填内容”**：  
父组件用子组件时，找到子组件挖的“坑”（按名字对应，没名字的是默认坑），把自己想放的内容（比如按钮、文字、其他组件）填进这个坑。

3. **Vue 帮忙“搭桥梁”**：  
渲染时，Vue 会自动把父组件填的内容，精准放到子组件对应的“坑”里；如果是作用域插槽（子组件想给父组件传点数据），Vue 还会把子组件的数据“递”给父组件，让父组件能用这些数据来填内容。

一句话总结：子组件挖坑、父组件填内容，Vue 负责把内容准确放进坑里，还能帮忙传数据。
# 面试官：你知道vue中key的原理吗？说说你对它的理解
简单说，key 就像节点的 “身份证”，让 Vue 能快速判断：哪些节点是新创建的、哪些是需要更新的、哪些是可以复用的。

就像给手机换手机号：

你原来的手机号（旧 key）绑定了一个微信（组件状态），现在你换了个新手机号（新的时间戳 key）：

原来的手机号作废（旧 key 组件被销毁），绑定的微信记录也跟着没了（状态清空）；
新手机号需要重新注册微信（新 key 组件重新渲染），所有信息都是全新的（状态重置）。

用时间戳当 key，就相当于每次都给组件换个 “新手机号”——Vue 会认为这是个全新的组件，必须删掉旧的、重建新的，自然就强制刷新了。
正确设置 key（用数据唯一稳定标识，如后端 ID）：能显著提升 diff 效率。Vue 可通过 key 直接匹配新旧节点，快速识别相同数据对应的节点，避免复杂内容比对，仅对新增、删除、移位的节点做最小化操作（复用无变化节点），减少 DOM 销毁与重建。
错误设置 key（用 index 或不唯一值）：与不设 key 效率基本一致。如用 index 当 key，列表顺序 / 数据变化时，key 会随 index 重新分配，Vue 会误判节点 “被修改”，仍需通过内容比对判断变化，无法发挥 key 的精准匹配作用，效率无提升。
设置无效 key（用每次渲染都变化的值，如随机数、时间戳）：反而降低 diff 效率。这类 key 每次渲染都变，Vue 会误判 “所有节点都是新的”，进而销毁全部旧 DOM 并重建新 DOM，产生大量无效操作，性能开销比不设 key 还大。
key 是虚拟节点的 “唯一身份证”，通过 精准匹配新旧节点、加速节点查找 优化虚拟 DOM 的 diff 流程，最终实现 “最小化真实 DOM 操作”—— 用对 key（唯一稳定标识）能提升性能、避免状态错位，用错则会失效甚至起反作用。
# 面试官：Vue中组件和插件有什么区别？
组件是是把html css js封装在一起方便复用，形成一个可复用、独立的功能模块
优点：重复使用

封装性与隔离性
组件内部的数据（data）和方法默认对外隔离，通过props接收外部数据，通过$emit触发外部事件，形成清晰的输入输出边界，避免全局污染。
调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单
插件是真强vue 功能的 扩展，插件的作用是为vue添加全局功能，插件的使用场景有很多，比如添加全局方法、添加全局指令、添加全局组件、添加全局事件、添加全局混入、添加全局过滤器、添加全局属性等
作用于全局，一次安装，全应用可用
通常用于解决通用性问题（如路由、状态管理、工具类功能）
需通过Vue.use()方法安装（Vue 3 中是app.use()）

二者的区别
编写形式
组件是常用的.vue格式
插件是必须暴露install 这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象
注册方式
组件是在组件中注册，插件是在main.js中注册
# vue 的局部注册和全局注册，
# 面试官：介绍一下grid网格布局
Grid 他是一个二维的布局方式，就是用横线竖线把页面分成格子，然后把内容放进这些格子里，想占几格就占几格，非常灵活。
display : grid;
grid-template-columns 
grid-rows-gap
grid-template-areas

# 面试官：说说你对git rebase 和 git merge的理解？区别？
# 说说 git 发生冲突的场景？如何解决？
# 面试官：说说 Javascript 数字精度丢失的问题，如何解决？
0.1 + 0.2 === 0.3 // false
原因是 javascript 数字精度丢失的问题
1/3 === 0.3333333333333333 // false
用 64 位双精度浮点数表示所有数字
这 64 位分为三部分：

1 位符号位（正 / 负）
11 位指数位（表示数值的量级）
52 位尾数位（表示数值的精度）
0.1 + 0.2 === 0.3 // false
通过上面的学习，我们知道，在javascript语言中，0.1 和 0.2 都转化成二进制后再进行运算
parseFloat(0.1)
const add = (a, b) => {
  const  a1 = (a.toString().split('.'))[1]
  const  b1 = (b.toString().split('.'))[1]
  const len = Math.pow(10, Math.max(a1.length, b1.length))
  
  return (a*len + b*len) / len
}
# 面试官：如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？
# 面试官：说说对中间件概念的理解，如何封装 node 中间件？
const middleware = (req, res, next) => {
  console.log('这是一个中间件')
  next()
}
app.use(middleware)
# 面试官：说说Git常用的命令有哪些？
# 面试官：css中，有哪些方式可以隐藏页面元素？区别?
display:none元素不可见，不会占用空间，不会触发事件
visibility:hidden元素不可见，会占用空间，不会触发事件
opacity:0元素不可见，会占用空间，会触发事件
position:absolute 元素不可见，不影响页面布局,会不会触发事件
transform:scale(0) 元素不可见，不影响页面布局,不会触发事件
# 面试官：DOM常见的操作有哪些？
创建元素
const divEl = document.createElement("div");
删除元素
removeChild()
修改元素
p.innerHTML = '这是一个段落'
添加
divEl.appendChild(p)
获取元素
const divEl = document.querySelector("#div1");

# 两边同步滚动
overflow-y: auto;
overflow-x: auto;

let a = ''
const s = (s1) => {
  if(a&& a !== s1) {
    return 
  }
  nextTick(() => {
    const l = s1 === 'left'? scrollLeft.value : scrollTop.value
    const el = s1 === 'left'? ref.value : ref.value
    if(l&&el) {
      l.scrollTop = el.scrollTop
      l.scrollLeft = el.scrollLeft
    }
    setTimeout(() => {
      a = s1
    }, 10)
    
  })
}
# 面试官：bind、call、apply 区别？如何实现一个bind?
bind call apply 他是改变this 指向
apply 是调用函数，并且传递参数
sum.apply(this, [1, 2, 3])
call 是调用函数，并且传递参数
sum.call(this, 1, 2, 3)
bind 是返回一个函数，并且可以传递参数
const s = sum.bind(this, 1, 2, 3)
和apply在传递参数上的区别
const a = function(...arr) {
  console.log(this,arr)
}
let c = {
  name: '张三'
}
let b = a.call(c, 1, 2, 3)
apply 是调用函数，并且传递参数
const a = function(...arr) {
  console.log(this,arr)
}
let c = {
  name: '张三'
}
let b = a.bind(c)
b(1,2,3)
a(1,2,3)
从上面可以看到，apply、call、bind三者的区别在于：

三者都可以改变函数的this对象指向
三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window
三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入
bind是返回绑定this之后的函数，apply、call 则是立即执行
#三、实现一个bind
# 面试官：举例说明你对尾递归的理解，有哪些应用场景(不熟悉)
递归：函数在内部调用自身的过程
const sum = (a, b) => {
  if (b === undefined) {
    return (b) => sum(a, b)
  }
  return a + b
}
尾递归，即在函数尾位置调用自身（或是一个尾调用本身的其他函数等等）。尾递归也是递归的一种特殊情形。尾递归是一种特殊的尾调用，即在尾部直接调用自身的递归函数
在尾部调用的是函数自身
可通过优化，使得计算仅占用常量栈空间，优化了时间
使用场景
数组sum
const sum1=(arr,sum = 0)=> {
  if(arr.length === 0) {
    return sum
  }
  return sum1(arr,sum+ arr.pop())
}
使用尾递归优化求斐波那契数列
const a  =(n,t = 1,tt = 1)=> {
  if(n === 1) {
    return t
  }
  return a(n-1,tt,t+tt)
}
# 面试官：元素水平垂直居中的方法有哪些？如果元素不定宽高呢？
. {
  width: 100px;
  height: 100px;
  position: relative;

}
. {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 50px;
  height: 50px;
  margin-top: -25px;
  margin-left: -25px;
}
. {
  width: 100px;
  height: 100px;
  position: relative;

}
. {
  position: absolute;
  top: 0
  left: 0
  right: 0
  bottom: 0
  margin: auto;
}
# 面试官：JavaScript原型，原型链 ? 有什么特点？
你说得对，每个 JavaScript 对象（除了null和undefined）都有一个原型对象，这个原型就像一个 "属性仓库"，存储着可以被多个[text](test.md)对象共享的属性和方法。

简单说，使用原型就是：要么直接用现成的，要么加点自己的让大家共用，要么基于已有原型造新对象。
自己写
array.prototype.sum = function() {
  return this.reduce((total, item) => total + item, 0);
}
const nums1 = [1, 2, 3];
console.log(nums1.sum()); // 输出6
function Star(){}：这是一个构造函数（可以理解为 “生产对象的模具”）。
prototype：每个函数（包括构造函数）都有一个 prototype 属性，它指向一个原型对象（可以理解为 “模具的默认配置”）。
prototype.constructor：原型对象里有一个 constructor 属性，它会指回构造函数本身（相当于 “配置上标记：我是被这个模具生产的”）dh.__proto__：每个实例对象都有一个 __proto__ 属性（这是浏览器提供的非标准但常用的属性，标准中用 Object.getPrototypeOf() 替代），它会指向构造函数的 prototype 对象（相当于 “实例说：我的默认配置来自这个模具的配置”）。
// 1. 定义构造函数（相当于“模具”）
function Student(name, age) {
  // 实例自身的属性
  this.name = name;
  this.age = age;
}

// 2. 给原型对象添加方法（所有实例共享）
Student.prototype.study = function() {
  console.log(`${this.name}在学习`);
};

Student.prototype.introduce = function() {
  console.log(`我叫${this.name}，今年${this.age}岁`);
};

// 3. 创建实例对象（用模具生产具体产品）
const student1 = new Student('小明', 12);
const student2 = new Student('小红', 13);

// 4. 使用实例的属性和方法
console.log(student1.name); // 自身属性：小明
student1.study(); // 来自Student原型：小明在学习
student2.introduce(); // 来自Object原型：我叫小红，今年13岁

// 5. 查看原型链关系
console.log(student1.__proto__ === Student.prototype); // true（实例→构造函数原型）
console.log(Student.prototype.__proto__ === Object.prototype); // true（构造函数原型→Object原型）
console.log(Object.prototype.__proto__); // null（原型链终点）

// 6. 原型链查找演示
student1.toString(); // 自身没有→Student原型没有→Object原型有（返回字符串）
（再找不到就返回 undefined）。
特点
1.共享复用：使用的实例对象都可以使用原型对象上的方法和属性
可以省内存 
2.链式查找：当访问一个对象的属性或方法时，会先在该对象自身查找，如果没有找到，就会去它的原型对象上查找，依次类推，直到找到为止。如果最终没有找到，就会返回 undefined。
3.动态更新： 当原型对象上的属性或方法发生改变时，所有基于该原型创建的实例对象都会受到影响。
4. 原型链的终点：Object.prototype 的 __proto__ 指向 null，形成了原型链的终点。

prototype 与 __proto__ 的区别
prototype 是函数特有的属性，用来存放所有实例共享的属性 / 方法（相当于 “模具的标准配件库”）。
__proto__ 是对象特有的属性（非标准但常用），指向自己的原型对象（相当于 “产品说明书上写的：配件来自哪个库”）。
比如：Student 是函数，有 prototype；student1 是对象，有 __proto__ 且指向 Student.prototype。
原型链与 instanceof 的关系
a instanceof B 的原理是：检查 a 的原型链上是否存在 B.prototype。
比如 student1 instanceof Student → true（student1.__proto__ 就是 Student.prototype）；
student1 instanceof Object → 也为 true（原型链上能找到 Object.prototype）。
instanceof 运算符
# 面试官：== 和 ===区别，分别在什么情况使用
=== 是严格相等运算符，它会检查值和类型是否都相等。
== 是相等运算符，它会在比较前先进行类型转换，然后再比较值是否相等。
== 是宽松相等运算符，它会在比较前尝试转换类型，然后再比较值。
一般是使用 === 来比较，只有在需要类型转换的情况下才使用 ==。
在使用 == 像if(val == null)它可以判段 null 和underfined
# 面试官：说说flexbox（弹性盒布局模型）,以及适用场景？
flex 它是一个布局方法，用于创建灵活的、自适应的一维或二维布局。
简单说，Flexbox 的核心优势就是：用极少的代码，搞定各种 “按行 / 列排列” 的布局，尤其是需要 “自适应空间” 和 “灵活对齐” 的场景，比传统布局方式省太多事。

属性：
1. display:flex
   flex-wrap:wrap
  flex-direction:row/column/row-reverse
.box {
    justify-content: flex-start | flex-end | center | space-between | space-around;
}
align-items:
  flex-start | flex-end | center | baseline | stretch;
align-content: flex-start | flex-end | center | space-between | space-around | stretch;
order它的数值越小，它排的就前面
align-self: flex-start | flex-end | center | baseline | stretch;
# 面试官：如何实现单行／多行文本溢出的省略样式？(继续复习这个，没有背完)
就是文本超过了一行或者多行，为了增加用户体验我们需要用省略号来表示
它分为两种，一个是单行文本溢出省略，一个是多行文本溢出省略
white-space:nowrap
overflow：hidden
text-overflow:ellipsis

 多行文本溢出省略

# 面试官：解释下什么是事件代理？应用场景？
就是把一个元素的响应事件的函数委托在它的父元素上
事件委托，就是把一个或者多个元素的事件响应函数委托在它的父元素上(而不是目标阶段)
当事件响应到目标元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数
使用场景：
我们有一个列表，列表之中有大量的列表项，我们要点击列表项的时候响应的事件
如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的
这时候就可以事件委托，把点击事件绑定在父级元素ul上面，然后执行事件的时候再去匹配目标元素
如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的
适合事件有click,mousedown,mouseup,keydown,
它的优点是
1.减小整个页面的内存，提高性能
2. 动态绑定： 当新添加的元素符合事件委托的条件时，无需重新绑定事件，即可自动生效。
缺点：focus,blur,这些事件没有事件冒泡机制，所以无法进行委托绑定事件
mousemove、mouseout这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的
mousemove 会在鼠标移动时高频触发（每秒数十次），如果在父元素委托，每次都要判断 event.target，性能消耗明显。
mouseout 触发时，event.target 可能是子元素内部的嵌套节点，判断逻辑复杂（需要频繁向上查找父元素），容易出错。
# 事件流分三个阶段，捕获，目标，冒泡（背一下）
# 面试官：v-if和v-for的优先级是什么？
v-if 使用于条件渲染，只有当条件为 true 时才会渲染元素。
v-for 使用于列表渲染，会根据数据数组的长度重复渲染元素。
优先级
v-for 的优先级高于 v-if，因为 v-for 是在渲染阶段执行的，而 v-if 是在条件渲染阶段执行的。
注意事项：
不要把 v-if 和 v-for 同时用在同一个元素上，因为 v-for 会比 v-if 先执行，这会导致性能问题。会造成性能的浪费

果避免出现这种情况，则在外层嵌套template（页面渲染不生成dom节点，他是虚里虚拟容器标签”），在这一层进行v-if判断，然后在内部进行v-for循环
这个是条件在循环外部
<template v-if="">
  <div v-for="">
    {{ item }}
  </div>
</template>
如果在条件判断在循环内部的话，
可以在computed: {

}里提前过滤那些不需要的显示的项
# 面试官：说一下 GET 和 POST 的区别？
他们都是HTTP协议发生的请求，GET和POST都是用来请求服务器的资源的
GET 方法是请求一个指定资源的表示形式，它一般是使用GET的请求应该只被用于获取数据

POST 方法是提交数据到服务器的，它一般是使用POST的请求应该只被用于修改服务器上的资源
参数位置
貌似从上面看到GET与POST请求区别非常大，但两者实质并没有区别

无论 GET还是 POST，用的都是同一个传输层协议，所以在传输上没有区别

当不携带参数的时候，两者最大的区别为第一行方法名不同

POST /uri HTTP/1.1 \r\n

GET /uri HTTP/1.1 \r\n

当携带参数的时候，我们都知道GET请求是放在url中，POST则放在body中

GET 方法简约版报文是这样的

GET /index.html?name=qiming.c&age=22 HTTP/1.1
Host: localhost
POST方法简约版报文是这样的

POST /index.html HTTP/1.1
Host: localhost
Content-Type: application/x-www-form-urlencoded

name=qiming.c&age=22
注意：这里只是约定，并不属于HTTP规范，相反的，我们可以在POST请求中url中写入参数，或者GET请求中的body携带参数

#参数长度
HTTP协议没有Body和 URL 的长度限制，对 URL限制的大多是浏览器和服务器的原因

IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持

这里限制的是整个URL长度，而不仅仅是参数值的长度

服务器处理长URL 要消耗比较多的资源，为了性能和安全考虑，会给 URL 长度加限制

#安全
POST比GET 安全，因为数据在地址栏上不可见

然而，从传输的角度来说，他们都是不安全的，因为HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文

只有使用HTTPS才能加密安全

#数据包
对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）

对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok

并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次

#参考文献

# 面试官：JavaScript字符串的常用方法有哪些？
1. 操作方法 
  增concat + 
  删 slice
  改
这里改的意思也不是改变原字符串，而是创建字符串的一个副本，再进行操作
trim() 去掉字符串首尾的空格 trimLeft() trimRight() repeat()
查 indexof includes
2. 转换方法
  转数组 split()
3. 模版匹配方法，replace(),代替，search () 

# 面试官：什么是防抖和节流？有什么区别？如何实现？
防抖： 就是n 秒后 执行一次，在n秒内重新触发，那么就会重新算
节流 就是n秒内执行一次，在你 n 秒内再次触发，那么就会被忽略
使用的场景： 防抖： 搜索框输入，用户输入完后，等用户停止输入n秒后，再去请求数据
节流： 滚动事件，用户滚动页面时，只需要监听一次滚动事件，然后在n秒内只执行一次事件处理函数
function ss(fn,delay) {
  let lastTime = 0
  return function(... args) {
    const now = Date.now()
    if(now - lastTime >= delay) {
      fn.apply(this,args)
      lastTime = now
    }
  }
}

function tt(fn,delay) {
  let time =  null
  return function(...args) {
    if(time) {
      clearTimeout(time)
    }
    time = setTimeout(() => {
      fn.apply(this,args)
      time = null
    }, delay)
  }
}
区别
他们都是为了降低回调的执行次数，节约计算资源
不一样的是
# 面试官：谈谈this对象的理解
this 是函数运行时自动生成的一个内部对象，只能在函数内部使用，指向调用函数的对象
this 在函数执行过程中，this 一旦被确认，就不可以在改了


默认绑定
全局环境中定义person函数，内部使用this关键字

var name = 'Jenny';
function person() {
    return this.name;
}
console.log(person());  //Jenny
上述代码输出Jenny，原因是调用函数的对象在游览器中位window，因此this指向window，所以输出Jenny

注意： 严格模式下，全局环境下的this指向undefined

隐式绑定
函数还可以作为某个对象的方法调用，这时this就指这个上级对象
new 绑定
new 绑定 是通过构造函数创建一个新对象，this 指向新对象
function test() {
　this.x = 1;
}

var obj = new test();
obj.x // 1

function fn()  
{  
    this.user = 'xxx';  
    return {};  
}
var a = new fn();  
console.log(a.user); //undefined

显示修改
call apply bind
call 和 apply 会立即执行函数，区别仅在于参数传递方式（单个传 vs 数组传）。
bind 不会立即执行，而是返回一个绑定好 this 的新函数，方便后续调用。
function sayHi(age) {
  console.log(`我是${this.name}，年龄${age}`);
}

const person = { name: "张三" };

// 用call让sayHi中的this指向person，同时传参数20
sayHi.call(person, 20); // 输出：我是张三，年龄20（立即执行）
他们的优先级 new > 显示 > 隐式 > 默认

# 面试官：typeof 与 instanceof 区别
typeof 根据值的类型直接判断，返回值是字符串
instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false
# 什么是隐式转换？(明天在看一遍)
# 面试官：说说new操作符具体干了什么？
1. 创建一个新的对象
2. 链接原型链
3. 绑定this，执行构造函数
4. 返回新对象
5. function mynew(func,...arrgs) {
    const obj = {}
    obj.__proto__ = func.prototype
    let res = func.apply(obj,arrgs)
    return res instanceof Object ? res : obj
   }
# 面试官：说说你对BOM的理解，常见的BOM对象你了解哪些？（不是很熟）
BOM 是一个浏览器对象模型，提供了独立于内容的，可以实现与浏览器的窗口进行交互，比如页面的前进，刷新，后退，浏览器窗口的变化，
history 操作url 的历史记录的对象
history.length histoty.back() history.forword()
history.go (n) 前进后退 xxxx URL 包含example.com的页面并跳转。如果历史记录里没有匹配的页面，操作将不会产生任何效果。
screen 屏幕对象比如像素宽度和像素高度
screen.width screen.height
navigator 浏览器对象，提供了浏览器的信息，比如浏览器的类型，版本，操作系统等 

location 浏览器对象，提供了当前页面的url信息

window 他是应该浏览器的接口，也是全局对象
# 面试官：说说对WebSocket的理解？应用场景？

webScoket 是一个网络传输协议，它实现了浏览器和服务器之间全双工通信，即服务器可以主动向客户端推送数据，客户端也可以主动向服务器发送数据
客户端和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输
特点：
1.  通信数据是可以在两个方向上同时传输，它相当于两个
单工通信方式的结合
2. 采用二进制帧进行数据传输，而不是文本帧
协议名： ws和wss 
ws 未加密的协议
wss 加密的协议,默认端口80或者443 几乎与HTTP 一样
握手 WebSocket也要有一个握手过程，然后才能正式收发数据

优点： 
1. 实时性好，相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少
2. 保持创连接状态：创建通信后，可省略状态信息，不同于HTTP每次请求需要携带身份验证
3. 较少的控制开销：数据包头部协议较小，不同于http每次请求需要携带完整的头部
使用的场景：
弹幕，媒体聊天，协调编程

# 面试官：说说地址栏输入 URL 敲下回车后发生了什么?
1. url 解析
协议： https (决定了什么通信规则)
域名： 决定访问的服务器地址
端口： 443（HTTPS 默认端口，HTTP 默认 80，若 URL 未写则补默认值，用于定位服务器上的 “应用程序”）；
路径： 定位服务器上的具体资源
查询参数：向服务器穿额外的常数，搜索关键词、分页信息）；
锚点（Fragment）：#title（仅在客户端生效，用于定位页面内的具体位置，不会发送到服务器）。
解析后，浏览器会判断 URL 是否合法（如是否包含非法字符），若不合法则提示错误；若合法则进入下一步。
2. DNS查询
3. 浏览器没有办法直接解析域名(www.example.com) 找到服务器，必须通过ip地址才可以(192.168.1.1) 定位服务器，因此需要通过 DNS（域名系统） 完成 “域名→IP” 的映射，过程类似 “查通讯录找电话”。
DNS 解析规则， “本地缓存优先，逐层查询” 的规则，具体顺序：
浏览器缓存：先查浏览器本地存储的 DNS 记录（如之前访问过该域名，会缓存一段时间，通常几分钟到几小时）；
操作系统缓存：若浏览器缓存没有，查操作系统本地的 DNS 缓存（如 Windows 的 hosts 文件、Mac 的 /etc/hosts 文件，可手动配置域名与 IP 的映射）；
路由器缓存：若操作系统缓存没有，查路由器的 DNS 缓存（路由器会存储常用域名的解析结果）；
ISP DNS 服务器：若前三级都没有，向用户的网络服务商（如电信、联通）的 DNS 服务器发起查询（这是 “递归查询” 的最后一步，ISP 服务器通常有大量域名缓存）；
3. TCP连接（“三次握手”，搭建通信通道）
拿到服务器的 IP 地址后，浏览器会通过 TCP 协议 与服务器建立可靠的通信连接
客服端发送请求连接
客户端向服务器发送一个 SYN（同步）报文，包含 “客户端的初始序列号”（如 seq=100），表示 “我想和你建立连接，我的初始序号是 100”；

服务器发 “确认 + 请求连接”：服务器收到 SYN 后，回复一个 SYN+ACK（同步 + 确认）报文，包含 “确认号”（ack=101，表示 “我收到了你的 100，下次请发 101 开始的数据”）和 “服务器的初始序列号”（如 seq=200），表示 “我同意连接，我的初始序号是 200，你也确认一下我的能力”；

客户端发 “确认”：客户端收到 SYN+ACK 后，回复一个 ACK（确认）报文，包含 “确认号”（ack=201，表示 “我收到了你的 200，下次请发 201 开始的数据”），表示 “我确认你的能力，连接可以正式用了”。
三次握手完成后，TCP 连接建立成功，双方可以开始传输数据。

发送 http 请求
当建立tcp连接之后，就可以在这基础上进行通信，浏览器发送 http 请求到目标服务器

请求的内容包括：

请求行：  “请求方法、请求路径、HTTP 版本”，如 GET /path/index.html HTTP/1.1
请求头 传递额外信息，告诉服务器客户端的软件环境（操作系统、浏览器及版本、渲染引擎等）。
请求主体 ：仅在 POST/PUT 等方法中存在，用于传递表单数据、JSON 数据等（如登录时的用户名和密码），GET 方法无请求体（参数通过 URL query 传递）。

响应请求：
当服务器接收到浏览器的请求之后，就会进行逻辑操作，处理完成之后返回一个HTTP响应消息，包括：

状态行： 状态行：包含 “HTTP 版本、状态码、状态描述”，如 HTTP/1.1 200 OK（200 表示请求成功，常见状态码还有 404 表示 “资源不存在”、500 表示 “服务器内部错误”、302 表示 “重定向”）；
响应头： 传递服务器的额外信息，如 Content-Type: text/html（告诉客户端响应体的类型是 HTML）
响应正文： 服务器返回的实际资源数据，如 HTML 文本、CSS 代码、JS 代码、JSON 数据、图片二进制流等。
6. 第六步：关闭 TCP 连接（“四次挥手”，断开通信通道）

客户端发 “请求关闭”：客户端（或服务器，谁先没有数据要传谁先发起）发送一个 FIN（结束）报文，包含序列号 seq=300，表示 “我没有数据要发给你了，准备关闭连接”；
服务器发 “确认”：服务器收到 FIN 后，回复 ACK 报文，确认号 ack=301，表示 “我收到你的关闭请求，我先处理完剩余数据，你等我通知”；
服务器发 “请求关闭”：服务器处理完剩余数据后，发送 FIN 报文，序列号 seq=400，表示 “我也没有数据要发给你了，你可以关闭连接了”；
客户端发 “确认”：客户端收到 FIN 后，回复 ACK 报文，确认号 ack=401，并等待一段时间（确保服务器收到确认），然后关闭连接；服务器收到 ACK 后，也关闭连接。

若为 3xx（重定向），则根据 Location 响应头跳转到新 URL，重复上述流程；
若为 4xx/5xx（错误），则显示对应的错误页面（如 404 页面）；
若为 200（成功），则根据 Content-Type 解析响应体：
若响应体是 HTML：进入 “DOM 构建” 流程（将 HTML 文本解析为 DOM 树，即文档的树形结构，每个 HTML 标签对应一个 DOM 节点）；
# 面试官：说说HTTP 常见的状态码有哪些，适用场景？
状态码：http的状态码是服务器告诉客服端当前请求响应的状态
通过状态码就能判断和分析服务器的运行状态
分类：
1 表示消息响应
2 表示成功响应
3 表示重定向响应
4 表示客户端错误响应
5 表示服务器错误响应
200 成功响应
201 成功响应，服务器创建新资源
204 成功响应，服务器成功处理请求，但无返回内容（如 DELETE 请求）
206 成功响应，服务器成功处理了部分请求（如 Range 请求），返回请求的部分内容。
400 客户端错误响应，请求语法错误，服务器无法理解
401 客户端错误响应，请求需要用户认证（如登录）
403 客户端错误响应，服务器拒绝执行请求（如权限不足）
404 客户端错误响应，请求的资源不存在
405 客户端错误响应，请求方法不被允许（如 POST 到一个不支持 POST 的资源）
408 客户端错误响应，请求超时（如服务器在规定时间内未响应）
500 服务器错误响应，服务器内部错误
502 服务器错误响应，网关错误（如反向代理返回无效响应）
503 服务器错误响应，服务器暂时不可用（如维护或过载）
504 服务器错误响应，网关超时（如反向代理在规定时间内未响应）
# 面试官：DNS协议 是什么？说说DNS 完整的查询过程?
他是域名系统，是进行域名和之间对应ip 地址进行转换的服务器
简单来说：负责把域名翻译成ip 地址
ip 地址：一长串可以唯一的标记网络上的计算机数据
域名：是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识
域名：
从上到下一次为根域名、顶级域名、二级域名、三级域名...

根域名（.，地球）→ 顶级域名（.com，商业分类）→ 二级域名（xxx，具体网站）→ 三级域名（www，网站首页）
查询方法：
递归查询：如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案


迭代查询：如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求
域名缓存：
浏览器缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗
操作系统缓存：操作系统的缓存其实是用户自己配置的 hosts 文件
查询过程
一句话总结整个流程
“浏览器查自己→系统查自己→找本地服务器查自己→本地服务器一层层问（根→顶级→权限）→拿到 IP 后，大家都存一份，再返回给浏览器”—— 本质就是 “先查自己的缓存，缓存没有就找更高级的‘向导’问，直到拿到答案，还不忘记下来下次用”。