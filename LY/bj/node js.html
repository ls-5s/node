<script>
    fs模块 - 读写文件
    // 加载 Node.js 文件系统模块，用于文件读写操作
    const fs = require('fs');

    // 异步写入文件：在当前目录创建 test.txt，内容为 "hello,Node.js"
    // 参数说明：文件路径、内容、回调函数(接收错误对象作为参数)
    fs.writeFile('./test.txt', 'hello,Node.js', (err) => {
        if (err) {
            // 错误处理：打印错误对象（包含错误类型、路径等信息）
            console.log(err);
        } else {
            // 成功提示：文件写入完成（注意：此时文件可能尚未完全落盘）
            console.log('hhhh');
        }
    });

    // 异步读取文件：读取刚创建的 test.txt 文件内容
    // 参数说明：文件路径、回调函数(接收错误对象和原始数据缓冲区)
    fs.readFile('./test.txt', (err, data) => {
        if (err) {
            // 错误处理：可能由于文件不存在、权限不足等原因
            console.log(err);
        } else {
            // 数据处理：将 Buffer 类型转换为 UTF-8 字符串输出
            console.log(data.toString());
        }
    });
</script>
<script>
    // Path 模块 - 路径处理
    // 建议: 在Node.js代码中, 使用绝对路径
    const path = require('path');
    const fs = require('fs'); // 引入 Node.js 文件系统模块，用于文件操作
    const path = require('path'); // 引入 Node.js 路径处理模块，用于跨平台路径拼接

    // 打印当前脚本所在的绝对目录路径（例如：/Users/username/project/src）
    console.log(__dirname);

    // 使用 path.join 拼接路径：将当前目录路径与 '../test.txt' 组合
    // __dirname + '../' 会导航到当前目录的父级目录
    // 最终路径示例：/Users/username/project/test.txt（假设脚本在 src 目录下）
    fs.writeFile(
        path.join(__dirname, '../test.txt'),
        '哈哈哈哈', // 要写入的文件内容（字符串形式）
        (err) => { // 写入完成后的回调函数
            if (err) {
                // 错误处理：打印包含错误类型和路径信息的错误对象
                // 可能的错误：权限不足、目录不存在、磁盘已满等
                console.log(err);
            } else {
                // 成功提示：仅表示写入请求已提交给操作系统
                // 注意：此时文件可能尚未完全写入磁盘（异步特性）
                console.log('hhhh');
            }
        }
    );
</script>

<script>
    //     URL中的端口号
    //     端口号的作用？
    // ➢ 标记区分服务器里不同的服务程序
    // 什么是 Web 服务程序？
    // ➢ 提供网上信息浏览的程序代码 
</script>

<script>
    /**
   * 目标：基于 http 模块创建 Web 服务程序
   *  1.1 加载 http 模块，创建 Web 服务对象
   *  1.2 监听 request 请求事件，设置响应头和响应体
   *  1.3 配置端口号并启动 Web 服务
   *  1.4 浏览器请求（http://localhost:2999）测试
   */
    // 1.1 加载 http 模块，创建 Web 服务对象
    // 引入 Node.js 内置的 http 模块，用于创建 HTTP 服务器
    const http = require('http');

    // 创建一个 HTTP 服务器实例
    // http.createServer() 接收一个回调函数，该函数会在每次接收到请求时被调用
    const server = http.createServer();

    // 监听 'request' 事件，每当有新请求到达服务器时触发
    // req 参数：包含客户端请求的信息（如 URL、请求头、请求体等）
    // res 参数：用于向客户端发送响应
    server.on('request', (req, res) => {
        // 设置响应头，指定响应内容的类型为纯文本，并使用 UTF-8 编码
        // 这确保中文等特殊字符能正确显示
        res.setHeader('Content-Type', 'text/plain;charset=utf-8');

        // 向客户端发送响应体内容，并结束本次请求-响应循环
        // 客户端将在浏览器中看到此消息
        res.end('欢迎使用 Node.js 和 http 模块创建的 Web 服务');
    });

    // 启动服务器，监听本地 3001 端口
    // 第二个参数是服务器启动成功后的回调函数
    server.listen(3001, () => {
        // 服务器成功启动后，在控制台打印提示信息
        console.log('Web 服务启动成功了');
        console.log('请访问: http://localhost:3001');
    });

    // 补充说明：
    // 1. 该服务器会响应所有类型的 HTTP 请求（GET、POST 等）
    // 2. 无论请求哪个路径，都会返回相同的响应内容
    // 3. 若要处理不同路径或请求方法，需在回调函数中添加路由逻辑

</script>
<script>
    /**
     * 目标：基于 Web 服务，开发提供网页资源的功能
     * 步骤：
     *  1. 基于 http 模块，创建 Web 服务
     *  2. 使用 req.url 获取请求资源路径，并读取 index.html 里字符串内容返回给请求方
     *  3. 其他路径，暂时返回不存在提示
     *  4. 运行 Web 服务，用浏览器发起请求
     */
    // const fs = require('fs')
    // const path = require('path')
    // // 1. 基于 http 模块，创建 Web 服务
    // const http = require('http')
    // const server = http.createServer()
    // server.on('request', (req, res) => {
    //     // 2. 使用 req.url 获取请求资源路径，并读取 index.html 里字符串内容返回给请求方
    //     if (req.url === '/index.html') {
    //         fs.readFile(path.join(__dirname, 'dist/index.html'), (err, data) => {
    //             res.setHeader('Content-Type', 'text/html;charset=utf-8')
    //             res.end(data.toString())
    //         })
    //     } else {
    //         // 3. 其他路径，暂时返回不存在提示
    //         res.setHeader('Content-Type', 'text/html;charset=utf-8')
    //         res.end('你要访问的资源路径不存在')
    //     }
    // })
    // server.listen(8084, () => {
    //     console.log('Web 服务启动成功了')
    // })
</script>
<script>
    // node.js 模块化
    // 定义基础URL常量，通常作为API请求的根路径
    // const baseURL = 'http://hajax.itheima.net';

    // /**
    //  * 计算数组元素的累加和
    //  * @param {Array} arr - 包含数值的数组
    //  * @returns {Number} - 数组所有元素的和
    //  */
    // const getArraySum = arr => arr.reduce(
    //     // 使用reduce方法累加每个元素的值
    //     (sum, item) => sum += item,
    //     0 // 初始累加值为0
    // );
    // // 导出模块成员，使其他文件可以引用
    // module.exports = {
    //     url: baseURL,         // 导出基础URL
    //     arraysum: getArraySum // 导出求和函数（命名为arraysum）
    // };

    // // 从当前目录的01.js文件导入模块
    // const obj = require('./01.js');

    // // 调用导入的求和函数计算数组总和
    // const sum = obj.arraysum([1, 222, 33]);

    // // 输出计算结果（预期输出：256）
    // console.log(sum);
</script>
<script>
    //     ECMAScript 标准规定如何默认导出和导入模块呢 ?

    //         导出：export default {}
    //     导入：import 变量名 from '模块名或路径'
    // 如何让 Node.js 切换模块标准为 ECMAScript ?

    //         运行模块所在文件夹, 新建 package.json 并设置
    //     { "type": "module" }
    // const baseURL = 'http://hajax.itheima.net'
    // const getArraySum = arr => arr.reduce
    //     ((sum, item) => sum += item, 0)
    // // 导出
    // export default {
    //     url: baseURL,
    //     arraysum: getArraySum
    // }
    // // 导入
    // import obj from './01.js'
    // const sum = obj.arraysum([1, 222, 33])
    // console.log(sum)

    //     导出
    // 使用 export 修饰定义语句，用于将模块内的变量、函数、对象等暴露出去，供其他模块引入使用。
    //         导入
    // 通过 import { 同名变量 } from '模块名或路径' 的形式，从指定模块路径中引入与 { } 
    // 内同名的变量、函数或对象等。这种方式是 命名导入，要求导入名称与导出名称严格一致。

    // 导出
    export const baseURL = 'http://hajax.itheima.net'
    export const getArraySum = arr => arr.reduce
        ((sum, item) => sum += item, 0)
    // 导入
    import { baseURL, getArraySum } from './01.js'
    const sum = getArraySum([1, 222, 33])
    console.log(sum)

</script>
<script>
    // 包
    // utils:软件包封装工具和方法进行使用
    // 项目包：主要是编写项目和业务逻辑
    // 要求 位置：根目录  必须存在的文件：package.json 文件作用：记录包的清单信息
    // {
    //    "name": "cz_utils",  // 软件包名称
    //      "version": "1.0.0",  // 软件包当前版本
    //      "description": "一个包含和字符串常用工具方法的包",  // 软件包简短描述
    //        "main": "index.js",  // 软件包入口点
    //         "author": "itheima",  // 软件包作者
    //            "license": "MIT"  // 软件包许可证（商用后可以用作者名字宣传）
    // }
    // 注意：导入软件包时，引入的默认是 index.js 模块文件 / main 属性指定的模块文件
    // npm 软件包管理器
    //     定义：npm 简介
    // npm 是Node.js标准的软件包管理器。
    //     在2017年1月时，npm仓库中就已有超过350000个软件包，这使其成为世界上最大的单一语言的仓库，并且可以确定几乎可以用于一切的软件包。
    //     它起初是作为下载安装和管理Node.js包依赖的方式，但现在它已成为前端JavaScript中使用的工具。
    //     使用：
    //     初始化清单文件：npm init - y（得到package.json文件，有则略过此命令）
    //     下载软件包：npm i 软件包名称
    // 使用软件包
    // npm - 安装所依赖
    // npm - 安装所有依赖
    //   问题：项目中不包含 node_modules，能正常运行？
    //   答案：不能，缺少依赖的本地软件包
    //   原因：因为，自己用 npm 下载依赖比磁盘传递速度要快很多
    //    解决：项目终端输入命令： npm i
    // 下载 package.json 中记录的所有软件包

    // npm 全局软件包 nodemon
    // 本地软件包: 当前项目内使用，封装属性和方法 存在于node_modules
    // 本机所以项目使用，封装命令和工具，存在系统设置的位置
    // nodemon：替代 node 命令，检测代码变更，自动重启程序
    // 1.npm i nodemon - g(-g 代码安装全局环境中)
    // 运行nodemon带执行的目标js 文件
</script>

<script>
    /**
 * 总结：
 * Node.js模块：
 *  概念：每个文件就是一个模块，独立作用域，按需加载，需使用特定语法导出导入
 *  CommonJS 标准语法：
 *    导出：module.exports = {}
 *    导入：require('模块名或路径')
 *  ECMAScript 标准语法：
 *    默认导出：export default {}
 *    默认导入：import 变量名 from '模块名或路径'
 *    命名导出：export 修饰定义语句
 *    命名导入：import { 同名变量 } from '模块名或路径'
 * Node.js包：
 *  概念：把模块文件，代码文件，其他资料聚合成一个文件夹
 *  项目包：编写项目需求和业务逻辑的文件夹
 *  软件包：封装工具/方法的文件夹（一般用 npm 管理）
 *    本地软件包：封装属性/方法，在当前项目中使用，例如：dayjs，lodash
 *    全局软件包：封装工具/命令，在本机中使用，例如：nodemon
 * 常用命令：
 *  执行 js 文件：node xxx
 *  初始化 package.json: npm init -y
 *  下载本地软件包：npm i 软件包名
 *  下载全局软件包：npm i 软件包名 -g
 *  删除软件包：npm uni 软件包名
 */
</script>
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 什么是 Webpack ?
        //定义：
        //本质上，webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时
        // 它会在内部从一个或多个入口点构建一个依赖图（dependency graph），
        // 然后将项目中所需的每一个模块组合成一个或多个 bundles。它们均为静态资源，用于展示你的内容。
        // 静态模块：指的是编码过程中的 html, css, js, 图片等固定内容的文件。
        //  打包：把静态模块内容，压缩，整合，转译等（前端工程化）。
        // 静态模块：指的是编写代码过程中的，html、css、js、图片等固
        //  打包：把静态模块内容，压缩、整合、转译等（前端工程化）
        // ✓ 把 less / sass 转成 css 代码
        // ✓ 把 ES6 + 降级成 ES5
        // ✓ 支持多种模块标准语法
        //         一、需求
        // 封装 utils 包，实现手机号长度和验证码长度校验功能，并在 src / index.js 中应用，最后通过 Webpack 进行打包观察。
        //             二、实现步骤
        // （一）项目初始化与代码编写
        //             新建项目：创建项目文件夹，在项目根目录通过命令行执行 npm init - y ，
        //           快速初始化项目，生成 package.json 文件用于记录项目信息和依赖配置。
        //             创建文件结构：在项目内创建 src 文件夹，用于存放源文件。
        //             编写校验代码：在 src 文件夹下创建 utils / check.js 文件，编写校验函数。示例代码如下：
        //             javascript
        //             // utils/check.js
        //             // 校验手机号长度
        //             export function checkPhoneLength(phone) {
        //                 return phone.length === 11;
        //             }
        //             // 校验验证码长度
        //             export function checkCodeLength(code) {
        //                 return code.length === 6;
        //             }
        //             在主文件引用：在 src / index.js 中引入 utils / check.js 并使用校验函数，示例代码如下：
        //             javascript
        //             // src/index.js
        //             import { checkPhoneLength, checkCodeLength } from './utils/check.js';
        //             const phone = '13800000000';
        //             const code = '123456';
        //             console.log(checkPhoneLength(phone));
        //             console.log(checkCodeLength(code));
        // （二）安装 Webpack 及相关工具
        //             在项目根目录的命令行中执行以下命令，将 webpack 和 webpack - cli 安装到项目的开发依赖中：
        //             bash
        // npm i webpack webpack-cli --save-dev
        //             安装完成后，打开 package.json 文件，在 "scripts" 字段中添加自定义打包命令：
        //             json
        //             {
        //                 "scripts": {
        //                     "build": "webpack"
        //                 }
        //             }
        // 此命令定义了在项目中执行 npm run build 时，实际运行的是 webpack 命令，用于启动打包流程。
        // （三）执行打包操作
        //             在项目根目录的命令行中执行以下命令进行打包：
        //             bash
        // npm run build
        // Webpack 会从 src / index.js 开始，分析项目中的模块依赖关系，将相关的 JavaScript 文件
        // 、样式文件等进行处理、优化和压缩，最终在项目根目录下生成 dist 文件夹，其中包含打包后的 main.js 文件，
        // 该文件可用于项目的最终运行部署。



        //         一、需求
        // 封装 utils 包，实现手机号长度和验证码长度校验功能，并在 src / index.js 中应用，最后通过 Webpack 进行打包观察。
        //         二、实现步骤
        // （一）项目初始化与代码编写
        //         新建项目：创建项目文件夹，在项目根目录通过命令行执行 npm init - y ，快速初始化项目，
        // 生成 package.json 文件用于记录项目信息和依赖配置。
        //         创建文件结构：在项目内创建 src 文件夹，用于存放源文件。
        //         编写校验代码：在 src 文件夹下创建 utils / check.js 文件，编写校验函数。示例代码如下：
        //         javascript
        //         // utils/check.js
        //         // 校验手机号长度
        //         export function checkPhoneLength(phone) {
        //             return phone.length === 11;
        //         }
        //         // 校验验证码长度
        //         export function checkCodeLength(code) {
        //             return code.length === 6;
        //         }

        //         在主文件引用：在 src / index.js 中引入 utils / check.js 并使用校验函数，示例代码如下：
        //         javascript
        //         // src/index.js
        //         import { checkPhoneLength, checkCodeLength } from './utils/check.js';
        //         const phone = '13800000000';
        //         const code = '123456';
        //         console.log(checkPhoneLength(phone));
        //         console.log(checkCodeLength(code));
        // （二）安装 Webpack 及相关工具
        //         在项目根目录的命令行中执行以下命令，将 webpack 和 webpack - cli 安装到项目的开发依赖中：
        //         bash
        // npm i webpack webpack - cli--save - dev
        //         安装完成后，打开 package.json 文件，在 "scripts" 字段中添加自定义打包命令：
        //         json
        //         {
        //             "scripts": {
        //                 "build": "webpack"
        //             }
        //         }
        // 此命令定义了在项目中执行 npm run build 时，实际运行的是 webpack 命令，用于启动打包流程。
        // （三）执行打包操作
        //         在项目根目录的命令行中执行以下命令进行打包：
        //         bash
        // npm run build
        // Webpack 会从 src / index.js 开始，分析项目中的模块依赖关系，将相关的 JavaScript 文件、
        // 样式文件等进行处理、优化和压缩，最终在项目根目录下生成 dist 文件夹，其中包含打包后的 main.js 文件，
        // 该文件可用于项目的最终运行部署。
        //         const path = require('path');
        //         module.exports = {
        //             // 入口
        //             entry: path.resolve(__dirname, 'src/login/index.js'),
        //             // 出口
        //             output: {
        //                 path: path.resolve(__dirname, 'dist'),
        //                 filename: 'login/index.js',
        //                 clean: true // 生成打包后内容之前，清空输出目录
        //             },
        //         }; 解释
        // 这段代码是一个 Webpack 配置文件（通常命名为 webpack.config.js），用于定义如何打包 JavaScript 项目。下面是对各部分的详细解释：
        //         1. 导入 Node.js 的 path 模块
        //         javascript
        //         const path = require('path');
        //         作用：path 是 Node.js 的内置模块，用于处理和转换文件路径。
        //         必要性：在配置 Webpack 时，需要使用绝对路径来确保路径在不同操作系统（如 Windows、macOS）上的一致性。
        //         2. 配置对象的整体结构
        //         javascript
        //         module.exports = {
        //             entry: ...,
        //             output: { ... }
        //         };
        //         作用：导出一个配置对象，Webpack 在启动时会读取这个对象来确定打包规则。
        //         3. 入口配置（entry）
        //         javascript
        //         entry: path.resolve(__dirname, 'src/login/index.js'),
        //             作用：指定 Webpack 开始构建的入口文件。
        //         路径解析：
        //         __dirname：Node.js 中的全局变量，表示当前文件（即 webpack.config.js）所在的目录。
        //         path.resolve()：将多个路径片段解析为一个绝对路径。例如，若 webpack.config.js 位于项目根目录，
        // 则入口路径为 项目根目录 / src / login / index.js。
        //         功能：Webpack 会从这个入口文件开始，递归地分析所有依赖（如 import 或 require 语句），构建依赖图。
        //         4. 出口配置（output）
        //         javascript
        //         output: {
        //             path: path.resolve(__dirname, 'dist'),
        //                 filename: 'login/index.js',
        //                     clean: true
        //         }
        //         4.1 输出目录（path）
        //         作用：指定打包后的文件将被输出到哪个目录。
        //         示例：path.resolve(__dirname, 'dist') 表示输出到项目根目录下的 dist 文件夹。
        //         4.2 输出文件名（filename）
        //         作用：指定打包后的文件名，支持路径嵌套。
        //         示例：'login/index.js' 表示在 dist 目录下创建 login 子目录，并将打包后的文件命名为 index.js，
        // 最终路径为 dist / login / index.js。
        //         4.3 清理输出目录（clean）
        //         作用：在每次打包前自动清空 output.path 指定的目录（即 dist 文件夹），避免旧文件残留。
        //         示例：若上次打包生成了 dist / login / old.js，下次打包时会先删除 dist 目录下的所有内容，再生成新文件。
        //         5. 完整配置的功能
        // 这个 Webpack 配置的核心功能是：
        // 从 src / login / index.js 文件开始，分析所有依赖。
        // 将所有依赖打包成一个 JavaScript 文件。
        // 将打包后的文件输出到 dist / login / index.js。
        // 每次打包前清空 dist 目录，确保输出的是最新内容。
        //         6. 常见应用场景
        //         多页面应用：为每个页面配置单独的入口和出口，例如：
        //         javascript
        //         module.exports = {
        //             entry: {
        //                 login: path.resolve(__dirname, 'src/login/index.js'),
        //                 home: path.resolve(__dirname, 'src/home/index.js')
        //             },
        //             output: {
        //                 path: path.resolve(__dirname, 'dist'),
        //                 filename: '[name]/index.js', // [name] 会被替换为入口名称（login 或 home）
        //                 clean: true
        //             }
        //         };

        //         生产环境优化：通过 clean 选项确保每次部署的都是最新代码，避免缓存问题。
        //         总结
        // 这个配置文件定义了 Webpack 的基本打包规则：从 src / login / index.js 入口开始，将所有代码打包到 dist / login / index.js，
        // 并在每次打包前清理旧文件。它是构建前端项目的基础配置，可根据需求扩展更多功能（如加载 CSS、处理图片、代码分割等）。

    </script>

</body>

</html>