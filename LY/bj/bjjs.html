<!-- <script>
      //页面弹出提示框
      alert("你好 JS_");
      //  文档输出内容
      document.write("js我来了");
      document.write("<h1>哈哈哈哈哈</h1>");
      // 控制台打印输出 给程序员看到
      
      console.log("它会魔法吗？？");
      //输入
      
      prompt("请输入你的名字", "张三");
      // 变量是用来存储数据的
      let age = 18; // 变量的声明和赋值
      let name = "张三"; // 字符串类型
      let isMarried = false; // 布尔类型
      let arr = [1, 2, 3]; // 数组类型
      let n = ["录音", "视频", "图片"]; // 数组类型
      let = { name: "张三", age: 18 }; // 对象类型
      // 变量的使用
      console.log(arr[1]); // 18
      console.log(arr.length); // 3
      const PI = 3.14; // 常量的声明和赋值
      // PI = 3.14159; // 常量的更新
      age = 19; // 变量的更新
      let ag = 20;
      // 模板字符串 外面用 `` 里面 ${变量名}
      document.write(`我今年${ag}岁了`);
    </script>
    外部的js<script src = ".js"></script>
    // true false; //布尔类型
    let iscool = true; //声明一个变量 iscool，并赋值为 true
    console.log(iscool); //打印变量 iscool 的值到控制台
    let age;
    console.log(age); //打印变量 age 的值到控制台
    // undefined; //未定义类型
    let name = null; //声明一个变量 name，并赋值为 null
    console.log(name); //打印变量 name 的值到控制台
    // null; //空类型、
    let a = 10;
    console.log(typeof a); //打印变量 a 的类型到控制台
    // number; //数字类型
    let num;
    console.log(typeof num); //提示用户输入一个数字，并将其赋值给变量 num
    console.log(1 + 1);
    //打印 1 + 1 的结果到控制台
    console.log("1" + 1);
    //隐性转换：将数字 1 转换为字符串 "1"，然后进行字符串拼接，结果为 "11"
    console.log("1" - 1);
    //隐性转换：将字符串 "1" 转换为数字 1，然后进行减法运算，结果为 0 加号要注意
    console.log(+"12341");
    //隐性转换：将字符串 "12341" 转换为数字 12341，结果为 12341
    console.log(+"12341abc");
    let str = "123";
    console.log(Number(str)); //将字符串 "123" 转换为数字 123，结果为 123
    console.log(Number("123abc")); //将字符串 "123abc" 转换为数字，结果为 NaN（不是一个数字）
    console.log(parseInt("123px")); //将字符串 "123px" 转换为整数 123，结果为 123
    console.log(parseInt("12.92")); //将字符串 "12.92" 转换为整数 12，结果为 12
    console.log(parseFloat("12.92")); //将字符串 "12.92" 转换为浮点数 12.92，结果为 12.92
    let a1 = +prompt("请输入一个数字:");
    let a2 = +prompt("请输入二个数字:");
    alert(`相加的和是:${a1 + a2}`); //将用户输入的两个数字相加，并将结果写入文档
    //赋值运算符
    let a3 = 10; //声明一个变量 a3，并赋值为 10
    a3 += 5; //将 a3 的值加上 5，并赋值回 a3 /=  *=  -= %=
    console.log(a3); //打印变量 a3 的值到控制台
    ++a3; //将 a3 的值加 1，并赋值回 a3
    console.log(a3);
    a3++; //将 a3 的值加 1，并赋值回 a3
    console.log(a3);
    //比较运算符
    console.log(1 == 1); //判断 1 是否等于 1，结果为 true
    console.log(1 == "1"); //判断 1 是否等于字符串 "1"，结果为 true（隐性转换）
    console.log(1 === "1"); //判断 1 是否严格等于字符串 "1"，结果为 false（没有隐性转换）
    console.log(1 != 1); //判断 1 是否不等于 1，结果为 false
    console.log(1 != "1"); //判断 1 是否不等于字符串 "1"，结果为 false（隐性转换）
    console.log(1 !== "1"); //判断 1 是否严格不等于字符串 "1"，结果为 true（没有隐性转换）
    console.log(1 > 2); //判断 1 是否大于 2，结果为 false
    console.log(NaN === NaN); //判断 NaN 是否严格等于 NaN，结果为 false（NaN 不等于任何值）

    // 逻辑与 — 假则假  
    console.log(true && true)            // 输出: true  
    console.log(false && true)           // 输出: false  
    console.log(3 < 5 && 3 > 2)          // 输出: true  
    console.log(3 < 5 && 3 < 2)          // 输出: false  
    console.log('-----------------------')

    // 逻辑或 — 真则真  
    console.log(true || true)            // 输出: true  
    console.log(false || true)           // 输出: true  
    console.log(false || false)          // 输出: false  
    console.log('-----------------------')

    // 逻辑非 — 取反  
    console.log(!true)                   // 输出: false  
    console.log(!false)                  // 输出: true  、

    // 1. 优先级 1 ：小括号()
    // 2. 优先级 2 ：一元运算符++ -- !
    // 3. 优先级 3 ：算数运算符 先 % / * + -
    // 4. 优先级 4 ：关系运算符 > >= < <=
    // 5. 优先级 5 ：相等运算符 == != === !==
    // 6.  优先级 6 ：逻辑运算符 先 && 后 ||
    // 7.  优先级 7 ：赋值运算符 =
    // 8. 优先级 8 ：逗号运算符,

    // 单分支语句  
    // if (false) {  
    //   console.log('执行语句')  
    // }  
    // if (3 > 5) {  
    //   console.log('执行语句')  
    // }  
    // if (2 === 2) {  
    //   console.log('执行语句')  
    // }  
    // 除了0，所有的数字都为真  
    if (-2) {
      console.log('执行语句')
    }
    console.log('---------------')
    // 1. 用户输入  
    let year = +prompt('请输入年份')
    // 2. 判断输出  
    if (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) {
      alert(`${year}年是闰年`)
    } else {
      alert(`${year}年是平年`)
    }
    // 1. 用户输入  
    let score = +prompt('请输入成绩：')
    // 2. 判断输出  
    if (score >= 90) {
      alert('成绩优秀，宝贝，你是我的骄傲')
    } else if (score >= 70) {
      alert('成绩良好，宝贝，你要加油哦~~')
    } else if (score >= 60) {
      alert('成绩及格，宝贝，你很危险~')
    } else {
      alert('成绩不及格，宝贝，我不想和你说话，我只想用篮子和你说话~')
    }  
    

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
</head>

<body>
  <script>
    // true false; //布尔类型
    let iscool = true; //声明一个变量 iscool，并赋值为 true
    console.log(iscool); //打印变量 iscool 的值到控制台
    let age;
    console.log(age); //打印变量 age 的值到控制台
    // undefined; //未定义类型
    
    let name = null; //声明一个变量 name，并赋值为 null
    console.log(name); //打印变量 name 的值到控制台
    // null; //空类型、
    let a = 10;
    console.log(typeof a); //打印变量 a 的类型到控制台
    // number; //数字类型
    let num;
    console.log(typeof num); //提示用户输入一个数字，并将其赋值给变量 num
    console.log(1 + 1);
    //打印 1 + 1 的结果到控制台
    console.log("1" + 1);
    //隐性转换：将数字 1 转换为字符串 "1"，然后进行字符串拼接，结果为 "11"
    console.log("1" - 1);
    //隐性转换：将字符串 "1" 转换为数字 1，然后进行减法运算，结果为 0 加号要注意
    console.log(+"12341");
    //隐性转换：将字符串 "12341" 转换为数字 12341，结果为 12341
    console.log(+"12341abc");
    let str = "123";
    console.log(Number(str)); //将字符串 "123" 转换为数字 123，结果为 123
    console.log(Number("123abc")); //将字符串 "123abc" 转换为数字，结果为 NaN（不是一个数字）
    console.log(parseInt("123px")); //将字符串 "123px" 转换为整数 123，结果为 123
    console.log(parseInt("12.92")); //将字符串 "12.92" 转换为整数 12，结果为 12
    console.log(parseFloat("12.92")); //将字符串 "12.92" 转换为浮点数 12.92，结果为 12.92
    let a1 = +prompt("请输入一个数字:");
    let a2 = +prompt("请输入二个数字:");
    alert(`相加的和是:${a1 + a2}`); //将用户输入的两个数字相加，并将结果写入文档
    //赋值运算符
    let a3 = 10; //声明一个变量 a3，并赋值为 10
    a3 += 5; //将 a3 的值加上 5，并赋值回 a3 /=  *=  -= %=
    console.log(a3); //打印变量 a3 的值到控制台
    ++a3; //将 a3 的值加 1，并赋值回 a3
    console.log(a3);
    a3++; //将 a3 的值加 1，并赋值回 a3
    console.log(a3);
    //比较运算符
    console.log(1 == 1); //判断 1 是否等于 1，结果为 true
    console.log(1 == "1"); //判断 1 是否等于字符串 "1"，结果为 true（隐性转换）
    console.log(1 === "1"); //判断 1 是否严格等于字符串 "1"，结果为 false（没有隐性转换）
    console.log(1 != 1); //判断 1 是否不等于 1，结果为 false
    console.log(1 != "1"); //判断 1 是否不等于字符串 "1"，结果为 false（隐性转换）
    console.log(1 !== "1"); //判断 1 是否严格不等于字符串 "1"，结果为 true（没有隐性转换）
    console.log(1 > 2); //判断 1 是否大于 2，结果为 false
    console.log(NaN === NaN); //判断 NaN 是否严格等于 NaN，结果为 false（NaN 不等于任何值）

    // 逻辑与 — 假则假  
    console.log(true && true)            // 输出: true  
    console.log(false && true)           // 输出: false  
    console.log(3 < 5 && 3 > 2)          // 输出: true  
    console.log(3 < 5 && 3 < 2)          // 输出: false  
    console.log('-----------------------')

    // 逻辑或 — 真则真  
    console.log(true || true)            // 输出: true  
    console.log(false || true)           // 输出: true  
    console.log(false || false)          // 输出: false  
    console.log('-----------------------')

    // 逻辑非 — 取反  
    console.log(!true)                   // 输出: false  
    console.log(!false)                  // 输出: true  、

    // 1. 优先级 1 ：小括号()
    // 2. 优先级 2 ：一元运算符++ -- !
    // 3. 优先级 3 ：算数运算符 先 % / * + -
    // 4. 优先级 4 ：关系运算符 > >= < <=
    // 5. 优先级 5 ：相等运算符 == != === !==
    // 6.  优先级 6 ：逻辑运算符 先 && 后 ||
    // 7.  优先级 7 ：赋值运算符 =
    // 8. 优先级 8 ：逗号运算符,

    // 单分支语句  
    // if (false) {  
    //   console.log('执行语句')  
    // }  
    // if (3 > 5) {  
    //   console.log('执行语句')  
    // }  
    // if (2 === 2) {  
    //   console.log('执行语句')  
    // }  
    // 除了0，所有的数字都为真  
    if (-2) {
      console.log('执行语句')
    }
    console.log('---------------')
    // 1. 用户输入  
    let year = +prompt('请输入年份')
    // 2. 判断输出  
    if (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) {
      alert(`${year}年是闰年`)
    } else {
      alert(`${year}年是平年`)
    }
    // 1. 用户输入  
    let score = +prompt('请输入成绩：')
    // 2. 判断输出  
    if (score >= 90) {
      alert('成绩优秀，宝贝，你是我的骄傲')
    } else if (score >= 70) {
      alert('成绩良好，宝贝，你要加油哦~~')
    } else if (score >= 60) {
      alert('成绩及格，宝贝，你很危险~')
    } else {
      alert('成绩不及格，宝贝，我不想和你说话，我只想用篮子和你说话~')
    }  
  </script>
</body>

</html>
//三元运算符
    let a = 1;
    let b = 2;
    let c = a > b ? a : b;
    console.log(c); // 2
    let d = +prompt("请输入一个数字：");
    if (d < 10) {
      alert(`0${d}`)
    }
    else {
      alert(d);
    }
    let x1 = +prompt("请输入一个数字：");
    let x2 = +prompt("请输入一个数字：");
    let x3 = prompt("请输入一个符号：");
    switch (x3) {
      case "+":
        alert(x1 + x2);
        break;
      case "-":
        alert(x1 - x2);
        break;
      case "*":
        alert(x1 * x2);
        break;
      case "/":
        alert(x1 / x2);
        break;
      default:
        alert("输入错误！")
    }

    数组 .push() 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度（重点）
    javascript
    arr.push(元素1, ..., 元素n)  

    javascript
const a1 = [1, 2, 3];
a1.push(10);
a1.unshift(100);
console.log(a1); 

在上述代码中，首先 a1.push(10) 把元素 10 添加到数组 a1 的末尾，此时 a1 变为 [1, 2, 3, 10]。接着，a1.unshift(100) 把元素 100 添加到数组 a1 的开头，最终 a1 变为 [100, 1, 2, 3, 10]。
综上所述，a1.push(10) 是把元素 10 添加到数组 a1 的末尾，a1.unshift(100) 是把元素 100 添加到数组 a1 的开头。

数组. splice() 方法 删除指定元素  
语法：  
arr.splice(start, deleteCount)  
arr.splice(起始位置, 删除几个元素)  

    a1.splice(1, 2);// 删除从索引1开始的2个元素
    a1.shift();// 删除第一个元素


    <script>
    const numbers = [5, 3, 8, 1, 2];
    numbers.sort((a, b) => a - b);
    console.log(numbers);
    const number = [5, 3, 8, 1, 2];
    number.sort((a, b) => b - a);
    console.log(number);
    // 函数 
    //  funtion 名字 {
    //  }

    // let a = [];
    // for (let i = 0; i < 4; i++) {
    //   a[i] = +prompt(`请输入第${i + 1}个数字：`)
    // }

    // function f1(arr = []) {
    //   let sum = 0
    //   for (let i = 0; i < arr.length; i++) {
    //     sum += arr[i];
    //   }
    //   return sum
    // }
    // document.write(f1(a))
    let a = +prompt('请输入一个数字：')
    let b = +prompt('请输入一个数字：')
    let c
    function f1(a, b) {
      return c = a > b ? a : b
    }
    document.write(f1(a, b))
    // const numbe = [5, 2, 9, 1, 4];
    // // 最大值
    // const max = Math.max(...numbe); //
    // // 最小值
    // const min = Math.min(...numbe); // 1

    // function fn(a, b) {
    //   console.log(a + b)
    // }
    // (1). 实参数数量多于形参    剩余的实参不参与运算  
    // fn(1, 2, 3)  
    // (2). 实参数数量少于形参    剩余的实参不参与运算  

    // fn(1) // 1 + undefined = NaN  
    //变量有一个坑，特殊情况：
    // 如果函数内部，变量没有声明，直接赋值，也当全局变量看，但是真的不推荐。

    // 函数表达式中的匿名函数
    // 在将函数赋值给一个变量时，可以使用匿名函数。
    //   const add = function (a, b) {
    //     return a + b;
    //   };
    //   console.log(add(3, 5)); 
    // (function () {
    //   // 立即执行函数
    //   document.write('立即执行函数')
    //   // 立即执行函数是一个函数定义后立即执行的函数。它可以用于创建一个独立的作用域，避免变量污染全局作用域。
    // })()
    // (function (x, y) {
    //   console.log(x + y);
    // })(1, 2);
    // { (function () { }()); }  
    {
      (function (x, y) {
        document.write(x + y);
      }(1, 2));
    }  

      // floor：是 Math 对象的方法，功能为 向下取整，即返回小于或等于输入数值的最大整数。例如：
      // Math.floor(3.9) 结果为 3；
      // Math.floor(-1.2) 结果为 - 2。
      let age = 18
      // console.log(false && age++) // age++ 不执行 — 假则假
      // console.log(age)
      
      // console.log(true || age++)
      // console.log(age)
      
      // console.log(11 && 22) // 都是真，这返回最后一个真值
      // console.log(11 || 22) // 输出第一个真值

      
 // let m = +prompt('请输入多少秒：')
    // let m1 = m % 60
    // let s = parseInt(m / 60 % 60)
    // let h = parseInt(m / 3600 % 24)
    // if (s < 10) {
    //   s = '0' + s
    // }
    // if (m1 < 10) {
    //   m1 = '0' + m1
    // }
    // if (h < 10) {
    //   h = '0' + h
    // }
    // document.write(`${m}秒 =
    // ${h}小时${s}分钟${m1}秒`)
    // floor：是 Math 对象的方法，功能为 向下取整，即返回小于或等于输入数值的最大整数。例如：
    // Math.floor(3.9) 结果为 3；
    // Math.floor(-1.2) 结果为 - 2。

    // let age = 18
    // console.log(false && age++) // age++ 不执行 — 假则假
    // console.log(age)

    // console.log(true || age++)
    // console.log(age)

    // console.log(11 && 22) // 都是真，这返回最后一个真值
    // console.log(11 || 22) // 输出第一个真值
    // console.log(Boolean("pink")) // true字符转换
    // console.log(Boolean(0)) // false数字转换

    // 1. Boolean（内容）
    // 记忆：`""`、`0`、`undefined`、`null`、`false`、`NaN` 转换为布尔值都是 `false`，其余则为 `true`。

    //### 公式转换：
    // 1. 有字符串的加法 `"" + 1`，结果是`"1"`
    // 2. 减法 - （像大多数数学运算一样）只能够用于数字，它会使字符串 `""` 转换为 0
    // 3. `null` 经过数学转换之后会变为 0
    // 4. `undefined` 经过数学转换之后会变为 NaN
  </script>

  <script>
          // let 对象名 = {} let 对象名 = new Object()  
          // let 对象名 = {
          //     属性名：属性值
          //     方法名：函数
          // }
          // let liyang = {
          //     uname: "li",
          //     age: 19,
          //     gender: "男",
          //     'goods-name': '小米10青春版'
          // }
          // // 便利对象
          // for (let k in liyang) {
          //     // console.log(k)//属性名 'uname'                                                                                                      
          //     console.log(liyang[k])
          // }
          // console.log(liyang)
          // console.log(typeof liyang)
          // // 对象的使用 对象名.属性名
  
          // console.log(liyang.age)
          // // 改
          // liyang.age = 111
          // console.log(liyang.age)
          // //增
          // liyang.like = "小说"
          // console.log(liyang.like)
          // console.log(liyang['goods-name'])
          // let obj = {
          //     uname: '刘德华',
          //     // 方法
          //     song: function (x, y) {
          //         document.write(x + y)
          //     },
          //     max1: function (x, y) {
          //         document.write(x = x > y ? x : y)
          //     }
          // }
          // // 方法调用 对象名.方法名
          // obj.song(2, 4)
          // obj.max1(1, 10000)
  
          // let arr = ['pink', 'red', 'blue']
          // for (let k in arr) {
          //     console.log(k)       // 数组的下标 索引号 但是是字符串 '0'
          //     console.log(arr[k])  // arr[k]
          // }
          // 定义一个存储了若干学生信息的数组  
          let students = [
              { name: '小明', age: 18, gender: '男', hometown: '河北省' },
              { name: '小红', age: 19, gender: '女', hometown: '河南省' },
              { name: '小刚', age: 17, gender: '男', hometown: '山西省' },
              { name: '小丽', age: 18, gender: '女', hometown: '山东省' }
          ]
  
          for (let i = 0; i < students.length; i++) {
              // console.Log(i)  // 下标索引号
              // console.Log(students[i])  // 每个对象  
              document.write(students[i].name)
          }
      </script>
      <script>
              //数学内置对象
              // console.log(Math.PI)
              // console.log(Math.ceil(9.1))
              // console.log(Math.floor(9.1))
              // console.log(Math.max(1, 2, 6566, 78777))
              // console.log(Math.min(1, 2, -1100))
              // console.log(Math.round(100.6))//四舍五入
              // // Math.random() 随机数函数，返回一个0 - 1之间，并且包括0不包括1的随机小数[0，1）
              // console.log(Math.floor(Math.random() * (10 + 1)))// 0到10随机本生成
              // //Math.floor(Math.random() * (M - N + 1)) + N  如何生成N-M之间的随机数
              // console.log(Math.floor(Math.random() * (10 - 5 + 1)) + 5)
              // let arr = ['赵云', '黄忠', '关羽', '张飞', '马超', '刘备', '曹操']
              // let k = Math.floor(Math.random() * (7))
              // console.log(arr[k])
      
              // // 3. splice(起始位置(下标)，删除几个元素)
              // arr.splice(k, 1)
              // console.log(arr)
              let a = +Math.floor(Math.random() * (10 + 1))
              let k = +3
              while (k--) {
                  let c = +prompt("请输入一个数：")
                  if (c > a)
                      alert("大了")
                  else if (c < a)
                      alert("小了")
                  else {
                      alert("对了")
                      break
                  }
              }
          </script>

            const a = [1, 2, 3]
            a.push(4)
            // 定义一个空数组 names
            const names = [] // 给数组的第0个位置赋值为 1
            names[0] = 1// 给数组的第1个位置赋值为 2
            names[1] = 2 // 给数组的第2个位置赋值为 3
            names[2] = 3// 定义一个空对象 obj
            const obj = {} // 给对象添加一个属性 uname，值为字符串 'pink老师'
            obj.uname = 'pink老师'

       

    .1 根据CSS选择器来获取DOM元素（重点）
    
    javascript
    document.querySelectorAll('css选择器')
    得到的是一个伪数组：
    有长度有索引号的数组
    但是没有 pop() push() 等数组方法
    想要得到里面的每一个对象，则需要遍历（for）的方式获得。
    注意事项
    哪怕只有一个元素，通过querySelectorAll()获取过来也是一个伪数组，里面只有一个元素而已。
    <p>1111</p>
    const p = document.querySelectorAll('p')
    p[0].style.color = 'red'
        <div class="box"> 123</div>
        <div class="box">abc</div>
        <p id="nav">导航栏</p>
        <ul>
          <li>测试</li>
          <li>测试</li>
          <li>测试</li>
        </ul>
    <div id="nav">11111</div>
    <ul class="lis">
      <li>测试</li>
      <li>测试</li>
      <li>测试</li>
    </ul>
    <script>
            // APls
            //  根据CSS选择器来获取DOM元素（重点）
            // 选择匹配的第一个元素
            // 1. 获取匹配的第一个元素
            // const box = document.querySelector('div')
            // const box = document.querySelector('.box')
            // console.log(box)
            //参数：
            // 包含一个或多个有效的CSS选择器 ** 字符串 **
            //     返回值：
            // CSS选择器匹配的 ** 第一个元素 **，一个 HTMLElement 对象。
            // const nav = document.querySelector('#nav')
            // console.log(nav)
            // // 我要获取第一个小 uLLi
            // const li = document.querySelector('ul li:first-child')
            const li = document.querySelectorAll('ul li')//选择所以的li 使用它，只有一个也要使用数组
            console.log(li)
            const nav = document.querySelector('#nav')
            nav.style.color = 'red'//单个修改 使用id
            const lis = document.querySelectorAll('.lis li')
            console.log(lis)
            for (let k = 0; k < lis.length; k++)
                console.log(lis[k])//每一个li对象
        </script>

        // 1获取元素
        const box = document.querySelector('.box')
        // 修改文字 使用innerText
        console.log(box.innerText)//获取文字内容
        box.innerText = '好好学习'//修改文字内容，不解析标签
        console.log(box)
        console.log(box.innerText)
        // innerHTML 解析标签
        box.innerHTML = '<strong>好好学习好</strong>'
        document.write(box.innerHTML)

        <h1 id="one"></h1>
            <h1></h1>
            <h1></h1>
            <h1></h1>
            <script>
                const a = [1, 2, 3, 4, 5]
                const ra = Math.floor(Math.random() * a.length)
                const a1 = document.querySelector('#one')
                a1.innerHTML = a[ra]
        
                a.splice(ra, 1)
                console.log(a)
                document.write(`<h1 id="one">${a1.innerHTML}</h1>`)
            </script> 
<img src="imager/4,74.png" alt="示例图片">
<script>
  // 获取图片元素
  const imgElement = document.querySelector('img');
  // 修改图片路径
  imgElement.src = 'imager/4.72.png';
  // 安全调试输出
  console.log('修改后的图片地址:', imgElement.src);
<script>
        const div = document.querySelector('div')
        div.style.height = '100px'
        div.style.width = '100px'
        div.style.backgroundColor = 'red'
        div.style.border = '100px solid bule'
    </script>
</script> -->

<!-- // const div = document.querySelector('div')
// div.className = 'box'//使用类名修改样式可以覆盖nav
// div.className = 'nav box'//也可以一起使用
// // 追加一个类，类名不加点，并且是字符串
// 元素.classList.add('类名')
// // 删除一个类
// 元素.classList.remove('类名')
// // 切换一个类，有还是没有啊，有就删掉，没有就加上
// 元素.classList.toggle('类名') -->
const div = document.querySelector('div')
div.classList.add('box')


<!-- 
    - 表单很多情况，也需要修改属性，比如点击眼睛，可以看到密码，本质是把表单类型转换为文本框
    - 正常的有属性有取值的 跟其他的标签属性没有任何区别
    ➢ 获取：DOM对象.属性名
    ➢ 设置：DOM对象.属性名 = 新值
    表单.value = '用户名'
    表单.type = 'password' -->
<!-- <input type="text" value="电脑">
    <script>
        const input = document.querySelector('input')
        console.log(input.value)//专门来获取表单内容
        input.value = 'ssss' -->
<!-- // 操作表单元素属性
        // 表单属性中添加就有效果，移除就没有效果，一律使用布尔值表示 如果为 true 代表添加了该属性 如果是 false 代表移除了该属性
        // 比如：disabled、checked、selected
    </script> -->
<!-- <input type="checkbox">
    <button disabled>点击</button>
    <script>
        const ll = document.querySelector('input')
        // console.log(ll.checked)
        ll.checked = true
    </script> -->


<!-- 性：标签天生自带的属性，比如 class、id、title 等，可以直接使用点语法操作，比如：disabled、checked、sel
        自定义属性：
        在 html5 中推出来了专门的 data - 自定义属性
        在标签上一律以 data - 开头
        在 DOM 对象上一律以 dataset 对象方式获取
        html -->

<!-- <div class="box" data-id="10">盒子</div>
<script>
  const box = document.querySelector('.box')
  console.log(box.dataset.id)
</script> -->
<!-- <button class="btn" disabled>我已经阅读用户协议(0)</button> -->
// 的定时器函数，作用是按照指定时间间隔重复执行函数
// setInterval(函数, 间隔时间)
// setInterval(function () {
// console.log('11111')
// }, 1000)
// function fu() {
// console.log('11111')
// }
// setInterval(fu, 1000)

// 关闭定时器

// let 变量名 = setInterval(函数, 间隔时间)
// clearInterval(变量名)
// const btn = document.querySelector('.btn')
// let i = 1;
// let k = setInterval(function () {
// i++;

// btn.innerHTML = `我已经阅读用户协议(${i})`
// if (i === 5) {
// clearInterval(k)
// btn.disabled = 0
// btn.innerHTML = '我已经阅读用户协议'
// }
// }, 1000)

<!-- 语法：
    元素对象.addEventListener (' 事件类型 ', 要执行的函数)
    事件监听三要素：
    事件源：那个 dom 元素被事件触发了，要获取 dom 元素
    事件类型：用什么方式触发，比如鼠标单击 click、鼠标经过 mouseover 等
    事件调用的函数：要做什么事 -->
<!-- <button class="btn">按钮</button>
    <script>
        const btn = document.querySelector('.btn')
        // 修改元素样式
        btn.addEventListener('click', function () {

        })
    </script> -->
<!-- 注意:
    事件类型要加引号
    函数是点击之后再去执行，每次点击都会执行一次 -->
<!-- <div class="box">
  我是广告
  <div class="box1">X</div>
</div>
<script>
  // 1. 获取事件源
  const box1 = document.querySelector('.box1')
  // 关闭的是大盒子
  const box = document.querySelector('.box')
  // 2. 事件侦听

  box1.addEventListener('click', function () {
    box.style.display = 'none'
  })
    // 使用document.querySelector方法选择文档中的第一个<div>元素，并将其赋值给常量div
      const div = document.querySelector('div');
    
      // 为div元素添加一个鼠标进入事件监听器
      // 当鼠标指针进入div元素的区域时，会触发该事件监听器的回调函数
      div.addEventListener('mouseenter', function () {
      // 当鼠标进入div元素时，在控制台输出字符串 '1111'
      console.log('1111');
      });
    
      // 为div元素添加一个鼠标离开事件监听器
      // 当鼠标指针离开div元素的区域时，会触发该事件监听器的回调函数
      div.addEventListener('mouseleave', function () {
      // 当鼠标离开div元素时，在控制台输出字符串 '1111'
      console.log('1111');
      });


      // 焦点事件 -->
// const input = document.querySelector('input')
// input.addEventListener('focus', function () {
// console.log('111')
// })
// // 没有了焦点触发
// input.addEventListener('blur', function () {
// console.log('111')
// })
// // 键盘事件
// // const input = document.querySelector('input')
// // input.addEventListener('keydown', function () {
// // console.log('键盘按下了')
// // })
// // input.addEventListener('keyup', function () {
// // console.log('键盘弹起了')
// // })
// // 用户输入文本事件 input
// const input = document.querySelector('input')
// input.addEventListener('input', function () {
// console.log(input.value)
// })
<!-- <button>点击</button> -->
<!-- <input type="text">
<> -->
// 事件对象
// type
// 获取当前的事件类型
// clientX / clientY
// 获取光标相对于浏览器可见窗口左上角的位置
// offsetX / offsetY
// 获取光标相对于当前 DOM 元素左上角的位置
// key
// 用户按下的键盘键的值
// 现在不提倡使用 keyCode

// const btn = document.querySelector('button')
// btn.addEventListener('click', function (e) {
// console.log(e)
// })
// const input = document.querySelector('input')
// input.addEventListener('keyup', function (e) {
// // console.log(e.key)
// if (e.key === 'Enter')
// console.log('222')
// })
//
// 事件对象
// type
// 获取当前的事件类型
// clientX / clientY
// 获取光标相对于浏览器可见窗口左上角的位置
// offsetX / offsetY
// 获取光标相对于当前 DOM 元素左上角的位置
// key
// 用户按下的键盘键的值
// 现在不提倡使用 keyCode

// const btn = document.querySelector('button')
// btn.addEventListener('click', function (e) {
// console.log(e)
// })
const input = document.querySelector('input')

// 每个函数里面都有this环境对象 普通函数里面this指向的是window
// function fn() {
// console.log(this)
// }
// window.fn()
const btn = document.querySelector('button')
btn.addEventListener('click', function () {
console.log(this) // btn对象
})

//前网页中所有被选中的 <cks> 元素的数量，并将这个数字赋值给变量 k。
  k = document.querySelectorAll('.ck:checked').length

  <div class="son"></div>
  </div>



  <!-- 1.1 事件流和两个阶段说明
        
            目标：能够说出事件流经过的2个阶段
            - 事件流指的是事件完整执行过程中流动路径
        
            说明：假设页面里有个div，当触发事件时，会经历两个阶段，分别是捕获阶段、冒泡阶段
            简单来说：捕获阶段是从父到子，冒泡阶段是从子到父
            实际工作都是使用事件冒泡为主-->
  <!-- 目标：简单了解事件捕获执行过程
            - 事件捕获概念：
            - 从DOM的根元素开始去执行对应的事件 (从外到里)
            - 事件捕获需要写对应代码才能看到效果
            - 代码：
            - DOM.addEventListener(事件类型, 事件处理函数, 是否使用捕获机制)
            - 说明：
            - addEventListener第三个参数传入true代表是捕获阶段触发（很少使用）
            - 若传入false代表冒泡阶段触发，默认就是false -->
  <!-- 目标：能够说出事件冒泡的执行过程
            - 事件冒泡概念：
            - 当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发。这一过程被称为事件冒泡
            - 简单理解：当一个元素触发事件后，会依次向上调用所有父级元素的同名事件
            - 事件冒泡是默认存在的 -->
  <!-- ### 1.4 阻止冒泡
            - **目标**：能够写出阻止冒泡的代码
            - **问题**：因为默认就有冒泡模式的存在，所以容易导致事件影响到父级元素
            - **需求**：若想把事件就限制在当前元素内，就需要阻止事件冒泡
            <!-- - **前提**：阻止事件冒泡需要拿到事件对象
            - **语法**：事件对象.stopPropagation()
            - **注意**：此方法可以阻断事件流动传播，不光在冒泡阶段有效，捕获阶段也有效 --> -->
  <!-- <script>
    const fa = document.querySelector('.father')
    const son = document.querySelector('.son') -->
  // 山东 济南 蓝翔 目标 (pink老师) 捕获阶段

  // document.addEventListener('click', function () {
  // alert('我是爷爷')
  // }, true)
  // fa.addEventListener('click', function () {
  // alert('我是爸爸')
  // }, true)
  // son.addEventListener('click', function () {
  // alert('我是儿子')
  // }, true)
  // 蓝翔 济南 山东 冒泡阶段
  // document.addEventListener('click', function () {
  // alert('我是爷爷')
  // }, false)
  // fa.addEventListener('click', function () {
  // alert('我是爸爸')
  // }, false)
  // son.addEventListener('click', function (e) {
  // alert('我是儿子')
  // e.stopPropagation()
  // }, false)
  // </script>

  // const btn = document.querySelector('button')
  // // btn.onclick = function () {
  // // alert('aaaa')
  // // // 事件移除解绑
  // // btn.onclick = null
  // // }
  // function fn() {
  // alert('点击了')
  // }
  // btn.addEventListener('click', fn)
  // // ### 1.5 解绑事件
  // // addEventListener方式，必须使用：
  // // removeEventListener(事件类型, 事件处理函数, [获取捕获或者冒泡阶段])
  // // 注意：匿名函数无法被解绑
  // btn.removeEventListener('click', fn)

  <!-- <ul>
    <li>第1个孩子</li>
    <li>第2个孩子</li>
    <li>第3个孩子</li>
    <li>第4个孩子</li>
    <li>第5个孩子</li>
    <p>1111111111</p>
  </ul>
  <script> -->

  // 点击每个小 li 当前 li 文字变为红色
  // 按照事件委托的方式 委托给父级，事件写到父级身上
  // 1. 获得父元素
  // const ul = document.querySelector('ul')
  // ul.addEventListener('click', function (e) {
  // //alert (11)
  // //this.style.color ='red'
  // //console.dir (e.target) // 就是我们点击的那个对象
  // //e.target.style.color ='red'
  // // 我的需求，我们只要点击 li 才会有效果
  // if (e.target.tagName === 'LI') {// li必须大写
  // e.target.style.color = 'red'
  // }
  // const form = document.querySelector('form')
  // form.addEventListener('submit', function (e) {
  // // 阻止默认提交
  // e.preventDefault()
  // })
  // <a href="#"></a>
  // const a = document.querySelector('a')
  // a.addEventListener('click', function (e) {
  // e.preventDefault()
  // })

  // })
  //
  <script>
    //       // 等待页面所有资源加载完毕，就回去执行回调函数
    //     window.addEventListener('load', function () {
    //           const btn = document.querySelector('button')
    //     btn.addEventListener('click', function () {
    //       alert(11)
    //     })
    //       })
    //   // img.addEventListener('Load', function () {
    //   //     // 等待图片加载完毕，再去执行里面的代码
    //   // }) 当浏览器已经完全加载 HTML 文档的结构，并且解析完成
    //   // （此时页面的 DOM 树构建完毕，但像图片、样式表、脚本等外部资源可能还未加载完 ），就会触发这个事件。
    //   // document.addEventListener('DOMContentLoaded', function () {
    //   //     const btn = document.querySelector('button')
    //   //     btn.addEventListener('click', function () {
    //   //         alert(11)
    //   //     })
    //   // })
    // // </script>
  // //

  // //


  // // <button>点击</button>
  // // </body>

  //
  //滚动事件
  // - 给 window 或 document 添加 scroll 事件
  // - 监听某个元素的内部滚动直接给某个元素加即可
  const div = document.querySelector('div')
  window.addEventListener('scroll', function () {
  // 整个页面滚动
  // 获取html 元素的写法
  // document.documentElement

  const n = document.documentElement.scrollTop
  if (n >= 100) {
  div.style.display = 'block'
  }
  else {
  div.style.display = 'none'
  }
  console.log(n)
  })
  //
  // div.addEventListener('scroll', function () {
  // // scrollTop 被卷去的头部
  // console.log(parseInt(div.scrollTop))
  const div = document.querySelector('div')
  // 检测盒子的位置 最近一级带有定位的祖先元素
  console.log(div.offsetLeft)
  console.log(div.offsetTop)

  scrollLeft 和 scrollTop 被卷去的头部和左侧 配合页面滚动来用，可读写
  clientWidth 和 clientHeight 获取元素宽度和高度 不包含 border、margin、滚动条，用于 JS 获取元素大小，只读属性
  offsetWidth 和 offsetHeight 获取元素宽度和高度 包含 border、padding、滚动条等，只读
  offsetLeft 和 offsetTop 获取元素距离自己定位父级元素的左、上距离 获取元素位置的时候使用，只读属性
  // })
  // // 时间对象
  // 1.1 实例化
  // 目标：能够实例化日期对
  // 在代码中发现了 new 关键字时，一般将这个操作称为实例化
  // 创建一个时间对象并获取时间
  // const date = new Date()//获取当前时间
  // console.log(date)
  // 指定时间
  // const date = new Date('2021-5-1 4:20:00')
  const specificDate = new Date(2025, 4, 22, 4, 20, 0);
  // console.log(date)
  // 日期对象的方法
  // 2.2 日期对象方法
  // 目标：能够使用日期对象中的方法写出常见日期
  // 使用场景：因为日期对象返回的数据我们不能直接使用，所以需要转换为实际开发中常用的格式
  // 方法 作用 说明
  // getFullYear() 获得年份 获取四位年份
  // getMonth() 获得月份 取值为 0 ~11
  // getDate() 获取月份中的每一天 不同月份取值也不相同
  // getDay() 获取星期 取值为 0 ~6
  // getHours() 获取小时 取值为 0 ~23
  // getMinutes() 获取分钟 取值为 0 ~59
  // getSeconds() 获取秒 取值为 0 ~59
  // const date = new Date()
  // console.log(date.getFullYear())
  // console.log(date.getMonth() + 1)
  // console.log(date.getDate())
  // 2.3 时间戳
  const time = +new Date('2222-02-21')

  // 目标：能够获得当前时间戳
  // 使用场景：如果计算倒计时效果，前面方法无法直接计算，需要借助于时间戳完成
  // 什么是时间戳：
  // 是指 1970 年 01 月 01 日 00 时 00 分 00 秒起至现在的 毫秒数，它是一种特殊的计量时间的方式
  // 算法：
  // 将来的时间戳 - 现在的时间戳 = 剩余时间毫秒数
  // 剩余时间毫秒数 转换为 剩余时间的 年月日时分秒 就是 倒计时时间
  // 比如 将来时间戳 2000ms - 现在时间戳 1000ms = 1000ms
  // 1000ms 转换为就是 0 小时 0 分 1 秒
  // const div = document.querySelector('div')
  // function d() {
  // const date = new Date()
  // let h = date.getHours()
  // let m = date.getMinutes()
  // let s = date.getSeconds()
  // h = h < 10 ? '0' + h : h // m=m < 10 ? '0' + m : m // s=s < 10 ? '0' + s : s // return `今天是:
    ${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}号 ${h}:${m}:${s}` // } // div.innerHTML=d() //
    setInterval(function () { // div.innerHTML=d() // }, 1000) // 3个方法时间戳 // const date=new Date() //
    console.log(date.getTime())//1 // console.log(+new Date())//2 // // 获取指定时间 // console.log(+new Date('2222-4-1
    10:30:00'))//2 // console.log(Date.now())//3 <!DOCTYPE html>
  

    <body>
      <!-- 父节点查找：
 parentNode 属性
    返回最近一级的父节点，找不到返回为 null
    子元素.parentNode 
    子节点查找：
    childNodes
    获得所有子节点，包括文本节点（空格、换行）、注释节点等
    children 属性（重点）
    仅获得所有元素节点
    返回的还是一个伪数组
    父元素.children -->
      <!-- <div class="dad">
        <div class="baby">x</div>
      </div>
      <script>
        const baby = document.querySelector('.baby')
        console.log(baby) // 返回dom对象
        console.log(baby.parentNode) // 返回dom对象
        const middle = document.getElementById('middle');
        // 找上一个兄弟
        const prev = middle.previousElementSibling;
        // 找下一个兄弟
        const next = middle.nextElementSibling;
      </script>

    </html>
    <ul>
      <li>我是老大</li>
    </ul>
    <script>
      // 1. 创建节点
      // const div = document.createElement('div')
      // console.log(div)
      // 2. 追加节点 作为最后一个子元素
      // document.body.appendChild(div)
      const ul = document.querySelector('ul')
      const li = document.createElement('li')
      li.innerHTML = '我是li'
      // ul.appendChild(li)
      // ul.children
      // 3. 追加节点
      // insertBefore(插入的元素, 放到哪个元素的前面)
      ul.insertBefore(li, ul.children[0])
    </script>
    <!-- - 克隆节点
          - // 克隆一个已有的元素节点
          - 元素.cloneNode(布尔值)
          - cloneNode会克隆出一个跟原标签一样的元素，括号内传入布尔值
          - 若为true，则代表克隆时会包含后代节点一起克隆
          - 若为false，则代表克隆时不包含后代节点
          - 默认为false -->
      <ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>
      </ul>
      <script>
        const ul = document.querySelector('ul')
        const s = ul.children[0].cloneNode(true)
        // 如果不加true 就不会clone 1
        //         ul.appendChild(s)
        //         目标：能够具备根据需求删除节点的能力
        //         若一个节点在页面中已不需要时，可以删除它
        // 在 JavaScript 原生 DOM 操作中，要删除元素必须通过父元素删除
        //         语法：
        //         父元素.removeChild(要删除的元素)
        //         注：
        //         如不存在父子关系则删除不成功
        //         删除节点和隐藏节点（display: none）有区别的：隐藏节点还是存在的，但是删除，则从 html 中删除节点
        ul.removeChild(ul.children[1])
      </script> -->


      <!-- m事件 在移动端-->
      <div></div>
      <script>
        const div = document.querySelector('div')
        // 1. 触摸
        div.addEventListener('touchstart', function () {
          console.log('开始摸我了')
        })
        // 2. 离开
        div.addEventListener('touchend', function () {
          console.log('离开了')
        })
        // 3. 移动
        div.addEventListener('touchmove', function () {
          console.log('一直摸，移动')
        })
      </script>
      <script>
        //     //BOM
        //     BOM（Browser Object Model） 是浏览器对象模型。通过图示可知，BOM 包含 window，而 window 下又包含 navigator、location、document、history、screen。
        // window 对象是一个全局对象，也是 JavaScript 中的顶级对象。
        // 像 document、alert()、console.log() 等都是 window 的属性，基本 BOM 的属性和方法都属于 window。
        // 所有通过 var 定义在全局作用域中的变量、函数，都会变成 window 对象的属性和方法。
        //     //       window 对象下的属性和方法调用时可以省略 window。
        //     .2 定时器 - 延时函数
        // JavaScript 内置一个用于让代码延迟执行的函数，称为 setTimeout。
        //     语法：setTimeout(回调函数，等待的毫秒数)。
        //     // setTimeout 仅执行一次，可理解为将一段代码延迟执行，调用时通常省略 window。
        //     setTimeout 仅仅只执行一次，所以可以理解为就是把一段代码延迟执行，平时省略 window。
        //     清除延时函数：
        //     let timer = setTimeout(回调函数，等待的毫秒数)
        //     clearTimeout(timer)
        // setTimeout 仅仅只执行一次，可理解为将一段代码延迟执行，调用时通常省略 window。
        //     清除延时函数：
        // 先通过 let timer = setTimeout(回调函数，等待的毫秒数) 定义延时函数并赋值给变量 timer，然后使用 clearTimeout(timer) 清除该延时函数。
        // setTimeout(function () {
        //   console.log('时间到了')
        // }, 2000)
        const img = document.querySelector('img')
        setTimeout(function () {
          img.style.display = 'none'
          console.log('消失了')
        }, 2000)
      </script>
      <!-- JS 执行机制
        同步任务：同步任务都在主线程上执行，形成一个 执行栈。
        异步任务：JS 的异步通过回调函数实现。一般异步任务有三种类型：
        普通事件，如 click、resize 等；
        资源加载，如 load、error 等；
        定时器，包括 setInterval、setTimeout 等。
        异步任务相关操作添加到 任务队列 中（任务队列也称为消息队列）。 -->
      <script>
          // console.log(location.href)
          // // console.log(location.href)
          // // 1. href 经常用href 利用js的方法去跳转页面
          // // location.href = 'http://www.baidu.com'
          //     1.4 location 对象
          // location 的数据类型是对象，它拆分并保存了 URL 地址的各个组成部分。
          //     常用属性和方法：
          // search 属性获取地址中携带的参数（符号 ? 后面部分），示例：console.log(location.search)。
          // console.log(location.search)
          // setTimeout(function () {
          //   location.href = 'text7.html'
          // }, 1000)
          //     .4 location 对象
          // location 的数据类型是对象，它拆分并保存了 URL 地址的各个组成部分。
          //     常用属性和方法：
          // hash 属性：获取地址中的哈希值（符号 # 后面部分），示例：console.log(location.hash)。
          // 该属性为后期 Vue 路由铺垫，常用于不刷新页面却能显示不同内容（如网易云音乐）。
          //   < script >
          //   // 检测 userAgent（浏览器信息）
          //   !(function () {
          //     const userAgent = navigator.userAgent
          //     // 验证是否为Android或iPhone
          //     const android = userAgent.match(/(Android);?[\s\/]+([\d.]+)?/)
          //     const iphone = userAgent.match(/(iPhone\sOS)\s([\d_]+)/)
          //     // 如果是Android或iPhone，则跳转至移动站点
          //     if (android || iphone) {
          //       location.href = 'http://m.itcast.cn'
          //     }
          //   })()
          // </>
  //         < body >
  //         这是pc端的页面
  //         < script >
  //         (function () { })()
  //     </>
  
  // </body >
  // <!-- 1.6 history 对象
  //     history 的数据类型是对象，主要管理历史记录， 该对象与浏览器地址栏的操作相对应，如前进、后退、历史记录等。
  //     常用属性和方法：
  //     | history 对象方法 | 作用 |
  //     | ---- | ---- |
  //     | back () | 可以后退功能 |
  //     | forward () | 前进功能 |
  //     | go (参数) | 前进后退功能，参数如果是 1 前进 1 个页面，如果是 - 1 后退 1 个页面 | -->
  //     < button > 后退</ >
  // <button>前进</button>
  // <script>
  //   const back = document.querySelector('button:first-child')
  //   const forward = back.nextElementSibling
  //   back.addEventListener('click', function () {
  //     history.back()
  //   })
  //   back.addEventListener('click', function () {
  //     history.back()
  //   })
    // </script>
    <!-- 本地存储介绍
    
      以前我们页面写的数据一刷新页面就没有了，是不是？
      随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，
      为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案。
      1、数据存储在用户浏览器中
      2、设置、读取方便，甚至页面刷新不丢失数据
      3、容量较大，sessionStorage和localStorage约5M左右
      常见的使用场景：
      https://todomvc.com/examples/vanilla-es6/ 页面刷新数据不丢失 -->
    <!-- 2.2 本地存储分类 - localStorage
      目标：能够使用 localStorage 把数据存储的浏览器中
      作用：可以将数据永久存储在本地（用户的电脑），除非手动删除，否则关闭页面也会存在
      特性：
      可以多窗口（页面）共享（同一浏览器可以共享）
      以键值对的形式存储使用 -->
    <script>
      // 本地纯存储只可以存字符串
      localStorage.setItem('uname', 'li')//存
      localStorage.getItem('uname')//取
      console.log(localStorage.getItem('uname'))
      // localStorage.removeItem('uname')// 删除
      //改
      localStorage.setItem('uname', 'yang')//存
    </script>
    script>
    // 本地存储复杂数据类型 无法直接使用
    const obj = {
    uname: 'pink 老师 ',
    age: 18,
    gender: ' 女 '
    }
    // localStorage.setItem('obj', obj)
    // console.log(localStorage.getItem('obj'))
    // 复杂数据类型存储必须转换为 JSON字符串存储
    // 复杂数据类型存储必须转换为 JSON字符串存储
    localStorage.setItem('obj', JSON.stringify(obj))
    // {"uname":"pink老师","age":18,"gender":"女"}
    // 取
    // console.Log(typeof localStorage.getItem('obj'))
    // 2、把JSON字符串转换为 对象
    console.log(JSON.parse(localStorage.getItem('obj')))
    
    </script>
    localStorage.setItem('odj', JSON.stringify(odj))
    const arr = JSON.parse(localStorage.getItem('odj')) || []

    // map
    // const arr = ['red', 'blue', 'green']
    // const a = arr.map(function (ele, index) {
    // console.log(ele) // 数组元素
    // console.log(index) // 数组索引号
    // return ele + "color"
    // })
    // console.log(a)
    // 数组中 join 方法
    // 作用：
    // join() 方法用于把数组中的所有元素转换一个字符串
    // 语法：
    // javascript
    const arr = ['red颜色', 'blue颜色', 'green颜色']
console.log(newArr.join('')) // red颜色blue颜色pink颜色
console.log(newArr.join('|')) // red颜色|blue颜色|pink颜色

核心步骤：
①：给 form 注册提交事件，要阻止默认提交事件（阻止默认行为）
事件对象.preventDefault () // 阻止默认行为
②：非空判断
如果年龄、性别、薪资有一个值为空，则 return 返回 ' 输入不能为空 ' 中断程序

<!-- 1.1 什么是正则表达式

  正则表达式（Regular Expression）是用于匹配字符串中字符串组合的模式。在 JavaScript 中，正则表达式也是对象
  通常用来查找、替换那些符合正则表达式的文本，许多语言都支持正则表达式。 -->
<!-- JavaScript 中定义正则表达式的语法有两种，我们先学习其中比较简单的方法：
  定义正则表达式语法：
  javascript
  const 变量名 = /表达式/
  其中 / / 是正则表达式字面量 -->
<!-- 判断是否有符合规则的字符串：
  test() 方法 用来查看正则表达式与指定的字符串是否匹配

  语法：
  javascript
  regObj.test(被检测的字符串) -->
<!-- 正则表达式检测查找 test 方法和 exec 方法有什么区别？

  test 方法 用于判断是否有符合规则的字符串，返回的是布尔值。找到返回 true，否则返回 false。

  exec 方法 用于搜索（查找）符合规则的字符串，找到返回数组，否则为 null。 -->
<script>
 
</script>
<!-- .3 元字符

  目标：能说出什么是元字符以及它的好处

  ● 普通字符：
  大多数的字符只能够描述它们本身，这些字符称作普通字符，例如所有的字母和数字。
  也就是说普通字符只能够匹配字符串中与它们相同的字符。

  ● 元字符(特殊字符)
  是一些具有特殊含义的字符，可以极大提高了灵活性和强大的匹配功能。
  ➢ 比如，规定用户只能输入英文26个英文字母，普通字符的话 abcdefghijklmn.....
  ➢ 但是换成元字符写法：[a-z] -->
<!-- 为了方便记忆和学习，我们对众多的元字符进行了分类：
  ➢ 边界符（表示位置，开头和结尾，必须用什么开头，用什么结尾）
  ➢ 量词（表示重复次数）
  ➢ 字符类（比如\d 表示 0~9） -->
<!-- 表格
  边界符 说明
  ^ 表示匹配行首的文本(以谁开始)
  $ 表示匹配行尾的文本(以谁结束) -->
<script>
  console.log(/^哈$/.test('哈')) // true 只有这种情况为true 否则全是false  
  console.log(/^哈$/.test('哈哈')) // false  
  console.log(/^哈$/.test('哈'))// true
  // 量词 * 类似 >= 0
  console.log(/^哈*$/.test(''))// true
  console.log(/^哈*$/.test('哈哈'))
  // 量词 + 类似 >= 1
  console.log(/^哈+$/.test('哈哈'))
  console.log(/^哈+$/.test(''))
  // 量词 ? 类似 0 || 1
  console.log(/^哈?$/.test('哈哈'))
  console.log(/^哈?$/.test('哈'))
  console.log(/^哈?$/.test(''))
  //量词 {n} 写到几，就必须出现几次
  console.log(/^哈{2}$/.test('哈哈哈'))
  //量词 {n,} 等于大于 >=n 
  console.log(/^哈{2,}$/.test('哈哈哈'))
  //量词 {n,m}  在n 到m 次
  console.log(/^哈{2,4}$/.test('哈')) 
</script>
// 1[] 匹配字符集合
// 后面的字符串只要包含 abc 中任意一个字符，都返回 true。
console.log(/[abcd]/.test('aololo'))// 只选一个
console.log(/^[abcd]$/.test('ab'))
console.log(/^[abcd]$/.test('a'))
console.log(/^[abcd]{3}$/.test('acd'))
// 字符类范围表示：使用连字符 - 表示范围。
// [a - z]：匹配小写英文字母（a 到 z，共 26 个）。
// [a - zA - Z]：匹配所有英文字母（大小写均可）。
// [0 - 9]：匹配 0 到 9 的数字。
// 示例正则解析：
// /^[a-z]$/：精确匹配单个小写字母（^ 表示字符串开头，$ 表示结尾）。如 'c' 匹配，返回 true。
// ^ [1 - 9][0 - 9]{ 4,} $（腾讯 QQ 号规则）：
// ^ [1 - 9]：第一位是 1 - 9 的数字（确保 QQ 号不以 0 开头）。
// [0 - 9]{ 4,}：后续至少 4 位数字（整体长度 ≥ 5 位，从 10000 开始）。
// $：字符串结尾，确保无多余字符。
console.log(/^[a-z]{3}$/.test('acd'))
console.log(/^[a-zA-Z0-9]{3}$/.test(123))
console.log(/^[1-9][0-9]{4,}$/.test(12300))
// 图中关于字符类取反的内容提取如下：
// 在字符类[] 中添加 ^ 作为取反符号。
// 示例：[^ a - z] 用于匹配除小写字母以外的字符。
// 注意：取反符号 ^ 需写在中括号[] 内。
console.log(/^[^a-z]{3}$/.test('AAA'))
图中预定义元字符类信息如下：
\d：匹配 0 - 9 数字，相当于 [0 - 9]。
\D：匹配 0 - 9 以外字符，相当于 [^0 - 9]。
\w：匹配字母、数字、下划线，相当于 [A - Za - z0 - 9_]。
\W：匹配除字母、数字、下划线外的字符，相当于 [^A - Za - z0 - 9_]。
\s：匹配空格（含换行符、制表符等），等同于 [\t\r\n\v\f]。
\S：匹配非空格字符，相当于 [^ \t\r\n\v\f]。
// 定义一个字符串变量 str，存储包含 'java' 相关内容的文本
const str = 'java是一门语言，学完Java,月薪过万';

// 使用字符串的 replace 方法对 str 进行替换操作
// /java/ig 是一个正则表达式，其中 'java' 是要匹配的内容
// 'i' 修饰符表示匹配时不区分大小写，所以 'java' 和 'Java' 都会被匹配
// 'g' 修饰符表示全局匹配，即会查找字符串中所有匹配的内容进行替换
// '前端' 是用于替换匹配到的 'java' 或 'Java' 的新内容
// 替换后的结果会存储在变量 ss 中
const ss = str.replace(/java/ig, '前端');

// 使用 console.log 方法将替换后的字符串 ss 输出到控制台
console.log(ss);
// 修饰符作用：约束正则执行细节（如是否区分大小写、是否多行匹配等）。
// 语法：/表达式/修饰符。
// 具体修饰符：
// i：单词 ignore 缩写，正则匹配时字母不区分大小写（示例：/a/i.test('a') 和 / a / i.test('A') 均返回 true）。
// 作用域
<!-- 1.1 局部作用域
    局部作用域分为函数作用域和块作用域。
    函数作用域：
    在函数内部声明的变量只能在函数内部被访问，外部无法直接访问。
    html
    <script>
        function getSum() {
            // 函数内部是函数作用域 属于局部变量
            const num = 10
        }
        console.log(num) // 此处报错 函数外部不能使用局部作用域变量 -->
<!-- 文字内容提取
    1.1 局部作用域
    局部作用域分为函数作用域和块作用域。
    2. 块作用域：
    在 JavaScript 中使用 {} 包裹的代码称为代码块，代码块内部声明的变量外部将【有可能】无法被访问。
    javascript
    for (let t = 1; t <= 6; t++) { // t 只能在该代码块中被访问 console.log(t) // 正常 }
     // 超出了 t 的作用域 console.log(t) // 报错 let
        声明的变量会产生块作用域，var 不会产生块作用域 
        const 声明的常量也会产生块作用域 不同代码块之间的变量无法互相访问 </script> -->
<!-- 1.3 作用域链
    作用域链本质上是底层的变量查找机制。
    在函数被执行时，会优先查找当前函数作用域中查找变量
    如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域 -->
    <!-- 文字内容提取
        1.4 垃圾回收机制
        内存的生命周期
        JS 环境中分配的内存，一般有如下生命周期：
        内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存
        内存使用：即读写内存，也就是使用变量、函数等
        内存回收：使用完毕，由垃圾回收器自动回收不再使用的内存 -->
    <!-- 全局变量一般不会回收 (关闭页面回收)
        一般情况下局部变量的值，不用了，会被自动回收掉
        内存泄漏：程序中分配的内存由于某种原因程序未释放或无法释放叫做内存泄漏 -->
    <!-- 文字内容提取
        拓展 - JS 垃圾回收机制 - 算法说明
        堆栈空间分配区别：
        栈（操作系统）：由操作系统自动分配释放函数的参数值、局部变量等，基本数据类型放到栈里面。
        堆（操作系统）：一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型放到堆里面。
        下面介绍两种常见的浏览器垃圾回收算法：引用计数法 和 标记清除法 -->
    <!-- 1.5 闭包
        目标：能说出什么是闭包，闭包的作用以及注意事项
        概念：一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域
        简单理解：闭包 = 内层函数 + 外层函数的变量
      
        文字内容提取
        闭包作用：封闭数据，提供操作，外部也可以访问函数内部的变量
        闭包的基本格式：
        // 常见的闭包的形式 外部可以访问使用 函数内部的变量
        function outer() {
        let a = 10
        function fn() {
        console.log(a)
        }
        return fn
        }
        // outer() === fn === function fn(){}
        // const fun = function fn() { }
        const fun = outer()
        fun() // 调用函数 -->
    
    <script>
      // 闭包的应用
      // 普通形式 统计函数调用的次数
      // let i = 0
      // function fn() {
      //     i++
      //     console.log(`函数被调用了${i}次`)
      // }
      // 因为 i 是全局变量，容易被修改
      // 闭包形式 统计函数调用的次数

      // // 闭包形式 统计函数调用的次数
      // function count() {
      //     let i = 0
      //     function fn() {
      //         i++
      //         console.log(i)
      //     }
      //     return fn
      // }
      // const fun = count()
      // fun()
      // 变量(了解)
      // 1. 把所有 var 声明的变量提升到当前作用域的最前面
      // 2. 只提升声明，不提升赋值
      // var num
      // console.log(num + '件')  // 此时num为undefined，输出 "undefined件"
      // num = 10
      // console.log(num)  // 输出 10
      // 函数的提升
      // 会把所以的函数声明提升到当前作用域的最前面
      // 只提升函数声明，不提升函数调用

      // 调用
      fu()
      // 声明
      function fu() {
        console.log('hhh ')
      }
        //  const arr = [1, 2, 3, 4, 5, 666]
        //   const a = [11111111, 2222222]
        //   console.log(Math.max(...arr))//最大值
        //   console.log(Math.min(...arr))// 最小值
        //   console.log(...arr, ...a)// 数组合并
    </script>
      // 2.3 箭头函数（重要）
      // 目标：能够熟悉箭头函数不同写法
      // 目的：引入箭头函数的目的是更简短的函数写法并且不绑定 this，箭头函数的语法比函数表达式更简洁
      // 使用场景：箭头函数更适用于那些本来需要匿名函数的地方
      // 学习路径：
      // 基本语法
      // 箭头函数参数
      // 箭头函数 this
      // 箭头函数
      const fu = () => {
      console.log('箭头函数')
      }
      fu()
      // 只有一个新参
      const s = (X) => {
      console.log(X)
      }
      s(8)
      // 5. 箭头函数可以直接返回一个对象
      const f = (uname) => ({ name: uname })
      console.log(f(' 刘德华 '))
      
      
      // 2. 箭头函数参数
      // 普通函数有 arguments 动态参数
      // 箭头函数没有 arguments 动态参数，但是有剩余参数...args
      const sum = (...arr) => {
      let s = 0
      for (let i = 0; i < arr.length; i++) { s +=arr[i] } return s } console.log(sum(1, 2, 3, 4, 5, 6)) // .3 箭头函数（重要） // 3.
        箭头函数 this // 在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的 this 值，非常令人讨厌。 // 箭头函数不会创建自己的 this，它只会从自己的作用域链的上一层沿用 this。 提取 // 2.
        箭头函数的 this 是上一层作用域的 this 指向 const fn=()=> {
        console.log(this) //window
        }
        fn()
        // 对象方法箭头函数 this
        const obj = {
        uname: 'pink 老师 ',
        sayHi: () => {
        console.log(this) //this 指向谁？window
        }
        }
        obj.sayHi()
        // 箭头函数 此时 this 指向了 window
        btn.addEventListener('click', () => {
        console.log(this)
        })
        // 普通函数 此时 this 指向了 DOM 对象
        btn.addEventListener('click', function () {
        console.log(this)
        })
         <script>
        // // 结构赋值之数组结构
        // const arr = [1, 2, 3]
        // // const [min, avg, max] = [1, 2, 3]或者
        // const [min, avg, max] = arr
        // console.log(min)
        // console.log(avg)
        // console.log(max)
        // const a = 1;
        // const b = 2;
        // [b, a] = [a, b];
        // console.log(a, b);

        // // console.log(a, b); // 输出: 2 1    
        // function f() {
        //     return [100, 60]
        // }
        // const [ma, mi] = f()
        // console.log(ma)
        // console.log(mi)

        // 提取
        // // 5. 按需导入赋值
        // const [a, b, , d] = [1, 2, 3, 4]
        // console.log(a) // 1
        // console.log(b) // 2
        // console.log(d) // 4
        // const arr = [1, 2, [3, 4]]
          // console.log(arr[0]) // 1
          // console.log(arr[1]) // 2
          // console.log(arr[2]) // [3,4]
          // console.log(arr[2][0]) // 3
      // 对象结构
      // const abj = {
      //     name 'ls',
      //     age: 18
      // } 、
      // 结构的语法

      // const { uname, age } = { uname: 'pink老师', age: 18 }
      // const name = obj.name
      //解构赋值中 {} 的作用：在对象解构赋值里，赋值运算符 = 左侧的 {} 用于批量声明变量，会从右侧对象提取属性值进行赋值。
      // 赋值规则：对象属性的值会赋值给与属性名相同的变量。
      // 变量命名注意事项：解构的变量名不能和外部变量名冲突，否则会报错。
      // 特殊情况：当对象中不存在与变量名一致的属性时，对应变量值为 undefined。
      // console.log(uname)
      // 对象解构的变量名 可以重新改名   旧变量名：新变量名
      // const { uname: username, age } = { uname: 'pink老师', age: 18 }
      // console.log(username)
      // console.log(age)
      // 数组对象的结构
      // const pig = [
      //     {
      //         name: 'li',
      //         age: 18
      //     }
      // ]
      // const [{ name, age }] = pig
      // console.log(name)
      // console.log(age)

      // 多级对象结构
      // const pig = {
      //     name: '佩奇',
      //     family: {
      //         mother: '猪妈妈',
      //         father: '猪爸爸',
      //         sister: '乔治'
      //     },
      //     age: 6
      // }
      // const { name, family: { mother, father, sister } } = pig
      // console.log(mother)
       // 遍历数组 forEach 方法（重点）

        //   forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数
        //    主要使用场景：遍历数组的每个
        //     被遍历的数组.forEach(function（当前数组元素，当前元素索引号） {
        // //      // 函数体
        // const arr = [1, 2, 34, 5, 6, 6]
        // const a = arr.forEach(function (item, index) {
        //   console.log(item)
        //   console.log(index)
        // })
    // 数据常用函数 深入对象
    // 创建对象的方式
    //1
    // const obj = new Object()
    // obj.name = 'ls'
    // console.log(obj)
    // 2.使用函数创造
    // 目标：能够利用构造函数创建对象。
    // 构造函数：是一种特殊的函数，主要用于初始化对象。
    // 使用场景：常规的 {... } 语法创建单个对象，若需创建多个类似对象（如创建佩奇对象后再创建乔治对象），
    // 需重复编写代码，此时可通过构造函数快速创建多个类似对象。
    // 定义一个名为 pig 的构造函数，用于创建猪的对象
    // 构造函数的作用是初始化对象的属性，当使用 new 关键字调用它时会创建一个新对象
    // 参数 name 表示猪的名字
    // 参数 age 表示猪的年龄
    // 参数 gd 表示猪的性别
    // function pig(name, age, gd) {
    //     // 将传入的 name 参数赋值给新创建对象的 name 属性
    //     this.name = name;
    //     // 将传入的 age 参数赋值给新创建对象的 age 属性
    //     this.age = age;
    //     // 将传入的 gd 参数赋值给新创建对象的 gd 属性
    //     this.gd = gd;
    // const a = new pig('li', 21, 'ma')
    // console.log(a)
    // 存在两个约定：
    // 命名规则：构造函数以大写字母开头。
    // 执行方式：只能通过 new 操作符来调用执行
    // 
          //实例成员和静态对象
            // 实例成员和静态成员
            // 1. 实例成员：实例对象上的属性和方法属于实例成员
            function Pig(name) {
              this.name = name
            }
            // const peiqi = new Pig('佩奇')
            // const qiaozhi = new Pig('乔治')
            // peiqi.name = '小猪佩奇'// 实例属性
            // console.log(peiqi)
            // console.log(qiaozhi)
            // console.log(peiqi === qiaozhi)
    // // 静态成员
    // function Pig(name) {
    //     this.name = name
    // }
    // Pig.eyes = 2 // 静态属性
    // Pig.sayHi = function () { // 静态方法
    //     console.log(this)
    // }
    // Pig.sayHi()
    // console.log(Pig.eyes)
      // const str = 'pink'
        // console.log(str)
        // 把简单数据类型包装复杂化(了解)
        // const str = new string('pink')
        // // javascript
        //   // 静态方法
        //   const o = { name: '佩奇', age: 6 }
        //   // // 获得对象的所有键，并且返回是一个数组
        //   // const arr = Object.keys(o)
        //   // console.log(arr) // ['name', 'age']
        //   console.log(Object.values(o))// 佩奇 6
        //   const abj = {}
        //   Object.assign(abj, o)// 对象的拷贝 = o U abj
        //   console.log(abj) //
    //        <div></div>
    // <ul>
    //     <li></li>
    //     <li></li>
    //     <li></li>
    // </ul>
    // <script>
    //     // 数组reduce方法
    //     // arr.reduce(function(上一次值, 当前值){ }, 初始化值)

    //     // const arr = [1, 5, 5];  // 创建一个包含三个数字的数组
    //     // const all = arr.reduce(function (prev, current) {  // 使用 reduce() 方法
    //     //     return prev + current;  // 对数组元素进行累加
    //     //     // prev（上一个累积值）
    //     //     // current（当前数组元素）
    //     // });
    //     // console.log(all)
    //     // const arr = [
    //     //     {
    //     //         name: '张三',
    //     //         salary: 10000
    //     //     },
    //     //     {
    //     //         name: '李四',
    //     //         salary: 10000
    //     //     },
    //     //     {
    //     //         name: '王五',
    //     //         salary: 10000
    //     //     }
    //     // ]
    //     // const all = arr.reduce(function (prev, current) {
    //     //     return prev + current.salary
    //     //     // prev 是和 current 是（当前数组元素）
    //     // }, 0)// 要写初始值
    //     // console.log(all)
    //     // // find()返回方法 数据库中满足提供测试函数的第一个元素的值。否则返回undefined。
    //     // const a = [1, 111111, 4344, 10]
    //     // const found = a.find(function (ar) {
    //     //     return ar > 1
    //     // })
    //     // console.log(found)
    //     // const array1 = [5, 12, 8, 130, 44];

    //     // const found = array1.find((element) => element > 10);

    //     // console.log(found);
    //     // // Expected output: 12
    //     // // 定义一个接受两个参数的箭头函数，返回一个包含两个属性的对象
    //     // const createPerson = (name, age) => ({name: name, age: age });
    //     // // 调用函数并输出结果
    //     // console.log(createPerson('Alice', 25));
    //     // const ss = [
    //     //     {name: "apples", quantity: 2 },
    //     //     {name: "bananas", quantity: 0 },
    //     //     {name: "cherries", quantity: 5 },
    //     // ];
    //     // const kk = ss.find((abj) => {
    //     //     return abj.name === 'apples'
    //     // })
    //     // console.log(kk)//  {name: "apples", quantity: 2 },
    //     // // {name: 'cherries', quantity: 5 }
    //     // const arr = ['red', 'blue', 'green']
    //     // const as = arr.find((item) => {
    //     //     return item === 'red'
    //     // })
    //     // console.log(as)
    //     // every()方法一个测试数据库内部的所有元素是否都通过指定函数的测试。它返回一个布尔值。
    //     // const array1 = [1, 30, 39, 29, 10, 13];
    //     // const isBelowThreshold = (currentValue) => currentValue < 40;
    //     // console.log(array1.every(isBelowThreshold));
    //     // Expected output: true
    //     // const arr = [1, 2, 3, 4, 5,]
    //     // arr.every((it) => it < 10)
    //     // console.log(arr.every((it) => it < 10))
    //     const spec = {size: '40cm*40cm', color: '黑色' }
    //             const a = Object.values(spec).join('/')
    //             const div = document.querySelector('div')
    //             div.innerHTML = a
    //             console.log(a)
    //             // 伪数组转化位置真数组
    //             const lis = document.querySelectorAll('ul li')
    //             const liss = Array.from(lis)
    //             console.log(liss)
    //             liss.pop()
    //             console.log(liss)
    
      // 字符串常用方法
      // 字符串装换为数组
      // split
      // const str = 'pink,red'
      // const arr = str.split(',')
      // console.log(arr)
      // const str = "The quick brown fox jumps over the lazy dog.";
      // const words = str.split(" ");
      // console.log(words[3]);
      // // Expected output: "fox"

      // const chars = str.split("");
      // console.log(chars[8]);
      // // Expected output: "k"

      // const strCopy = str.split();
      // console.log(strCopy);
      // // Expected output: Array ["The quick brown fox jumps over the lazy dog."]

      // substring字符串截取
      // const str = "Mozilla";
      // console.log(str.substring(1, 3));// 2.2 结束的索引号不包含想要截取的部分
      // // Expected output: "oz"
      // console.log(str.substring(2));// 2 到后面所有
      // // Expected output: "zilla"

      // String该startsWith()方法用于判断当前字符串是否还有另外一个给定的子字符串开头，并根据判断结果返回true或false。
      // const str = "To be, or not to be, that is the question.";
      // console.log(str.startsWith("To be")); // true
      // console.log(str.startsWith("not to be")); // false
      // console.log(str.startsWith("not to be", 10)); // true
      // // 调用 str.startsWith("not to be", 10) 的过程如下：
      // // "not to be" 是要检查的子字符串。
      // // 10 是起始位置。这个参数告诉 JavaScript 从索引 10 开始查找子字符串。
      // // str 在索引 10 处的子字符串是 "not to be"（从索引 10 开始，字符串是 "not to be ignored"）。
      // // 因此，str 从位置 10 开始，确实以 "not to be" 开头，startsWith() 返回 true。
      // console.log(str.startsWith("be", 3));

      // String值的includes()方法执行区分大小写的搜索，新增是否可以在一个字符串中找到另一个字符串，并根据情况返回true或false。
      const str = "To be, or not to be, that is the question.";
      console.log(str.includes("To be")); // true
      console.log(str.includes("question")); // true
      console.log(str.includes("nonexistent")); // false
      console.log(str.includes("To be", 1)); // 从1号位置开始
      console.log(str.includes("TO BE")); // false
      console.log(str.includes("")); // true
    
    const ss = 12.123456789
    console.log(ss.toFixed(3))// 保留小数点3位
    //       </script>
    // </script>
      // 构造函数 公共的属性和方法 封装到 Star 构造函数里面了
      function Star(name, age) {
      this.name = name
      this.age = age
      // this.sing = function () {
      // console.log('我会唱歌')
      // }
      }
      Star.prototype.sing = function () {
      console.log('我会唱歌')
      }
      const li = new Star('li', 21)
      li.sing()
      console.log(li)
      // 原型对象
      // 3.1 原型
      // 目标：能够利用原型对象实现方法共享
      // 构造函数通过原型分配的函数是所有对象所 共享 的。
      // JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象，所以我们也称为原型对象。
      // 这个对象可以挂载函数，对象实例化不会多次创建原型上的函数，节约内存。
      // 我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。
      // 构造函数和原型对象中的 this 都指向实例化的对象。
        // 定义一个包含数字的数组
        const arr = [1, 2, 3, 1000];
        
        // 下面这行代码被注释掉了，它的作用是使用 Math.max 结合扩展运算符来找出数组中的最大值
        // console.log(Math.max(...arr));
        
        // 以下是自定义数组扩展方法的注释说明
        // 1. 我们定义的这个方法，任何一个数组实例对象都可以使用
        // 2. 自定义的方法写到 数组.prototype 身上
        
        // 为 Array 的原型对象添加一个名为 max 的方法，用于找出数组中的最大值
        Array.prototype.max = function () {
        // 使用扩展运算符将数组展开作为 Math.max 函数的参数，返回数组中的最大值
        return Math.max(...this);
        };
        
        // 以下两行代码被注释掉了，它们展示了不同的数组定义方式
        // const arr = [1, 2, 3];
        // const arr = new Array(1, 2);
        
        // 调用自定义的 max 方法，找出数组 arr 中的最大值并将其打印到控制台
        console.log(arr.max());
        <script>
          function Star() {

          }
          Star.prototype = {
            // 从新指回创造这个原型对象的 构造函数
            constructor: Star,
            sing: function () {
              console.log('唱歌')
            },
            dance: function () {
              console.log('跳舞')
            }
          }
          const ld = new Star()
          console.log(Star.prototype)
          //  constructor 属性
          // 在哪里？ 每个原型对象里面都有个 constructor 属性（constructor 构造函数）。
          // 作用：该属性指向该原型对象的构造函数，简单理解，就是指向 “我的爸爸”，即 “我是有爸爸的孩子”。
          // console.log(Star.prototype.constructor === Star)

        </script>
        <!-- <script>
          function Star() {

          }

          const ld = new Star()
          console.log(ld)
          // 对象原型__proto__ 指向 构造函数的原型对象prototype 
          console.log(ld.prototype === ld.__proto__)
          // proto 是 JS 非标准属性
          //         [[prototype]] 和__proto__意义相同
          // 用来表明当前实例对象指向哪个原型对象 prototype
          // __proto__对象原型里面也有一个 constructor 属性，指向创建该实例对象的构造函数、Star
          console.log(ld.__proto__.constructor === Star)
        </script> -->

          // 定义 Person 构造函数，初始化人类共有的属性（眼睛和头）
          function Person() {
          this.eyes = 2; // 每个实例都有 2 只眼睛
          this.head = 1; // 每个实例都有 1 个头
          }
          
          // 定义 Woman 构造函数，用于创建女性对象
          function Woman() {
          }
          // 让 Woman 的原型指向 Person 的实例，实现继承 Person 的属性
          Woman.prototype = new Person();
          // 修正 Woman 原型的 constructor 属性，使其正确指向 Woman 构造函数
          Woman.prototype.constructor = Woman;
          // 为 Woman 的原型添加专属方法 baby
          Woman.prototype.baby = function () {
          console.log('宝贝');
          }
          const red = new Woman();
          console.log(red); // 打印 Woman 实例，可查看继承的属性和方法
          
          // 定义 Man 构造函数，用于创建男性对象
          function Man() {
          }
          // 让 Man 的原型指向 Person 的实例，实现继承 Person 的属性
          Man.prototype = new Person();
          // 修正 Man 原型的 constructor 属性，使其正确指向 Man 构造函数
          Man.prototype.constructor = Man;
          const pink = new Man();
          console.log(pink); // 打印 Man 实例，可查看继承的属性
          以下是提取的原型链 - 查找规则内容：
          当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。
          如果没有就查找它的原型（也就是 __proto__ 指向的 prototype 原型对象）。
          如果还没有就查找原型对象的原型（Object 的原型对象）。
          依此类推一直找到 Object 为止（null）。
          __proto__ 对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。
          可以使用 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。
          uname: 'pink', // 定义对象obj的uname属性，值为字符串'pink'
          age: 18 // 定义对象obj的age属性，值为18
          };
          // 原始对象
          const original = {
          name: "Alice",
          age: 30,
          hobbies: ["reading", "painting"],
          address: {
          city: "New York",
          zip: "10001"
          }
          };
          
          // 浅拷贝方法1: Object.assign()
          const clone1 = Object.assign({}, original);
          
          // 浅拷贝方法2: 展开语法
          const clone2 = { ...original };
          
          // 修改浅拷贝对象的基本类型属性
          clone1.age = 31;
          console.log(original.age); // 输出: 30（不受影响）
          
          // 修改浅拷贝对象的引用类型属性（数组）
          clone1.hobbies.push("swimming");
          console.log(original.hobbies); // 输出: ['reading', 'painting', 'swimming']（原对象被修改）
          
          // 修改浅拷贝对象的嵌套对象
          clone2.address.city = "Los Angeles";
          console.log(original.address.city); // 输出: 'Los Angeles'（原对象被修改）
          <script src='lodash.js'></script>
          <script>
            // 深拷贝
            // function deepCopy(newObj, oldObj) {
            //     if (oldObj === null) {
            //         newObj = null;
            //         return;
            //     }
            //     for (let k in oldObj) {
            //         if (oldObj.hasOwnProperty(k)) { // 只处理对象自身属性，避免原型链属性
            //             if (oldObj[k] instanceof Array) {
            //                 newObj[k] = [];
            //                 deepCopy(newObj[k], oldObj[k]);
            //             } else if (oldObj[k] instanceof Object) { // 处理普通对象，但需排除 null（已在开头处理）
            //                 newObj[k] = {};
            //                 deepCopy(newObj[k], oldObj[k]);
            //             } else {
            //                 newObj[k] = oldObj[k];
            //             }
            //         }
            //     }
            // }

            // // 测试数据
            // let obj = {
            //     uname: "张三",
            //     age: 18,
            //     hobby: ["乒乓球", "足球"],
            //     address: { city: "北京" }
            // };
            // let o = {}; // 初始化新对象
            // deepCopy(o, obj); // 执行深拷贝

            // // 验证深拷贝效果
            // o.hobby[0] = "篮球"; // 修改新对象的数组元素
            // o.address.city = "上海"; // 修改新对象的嵌套对象属性

            // console.log("原对象 obj:", obj);
            // console.log("新对象 o:", o);
            // 检查原对象是否被修改：
            // 原对象的 hobby 应仍为 ["乒乓球", "足球"]，address.city 应为 "北京"

            // lodash 的 _.cloneDeep() 方法是最可靠的深拷贝解决方案，支持所有数据类型和循环引用：
            // let obj = {
            //     uname: "张三",
            //     age: 18,
            //     hobby: ["乒乓球", "足球"],
            //     address: { city: "北京" }
            // };
            // const clone = _.cloneDeep(obj)
            // console.log(clone)


            // 使用 JSON.parse(JSON.stringify())
            let obj = {
              uname: "张三",
              age: 18,
              hobby: ["乒乓球", "足球"],
              address: { city: "北京" }
            };
            console.log(JSON.stringify(obj))
            console.log(JSON.parse(JSON.stringify(obj)))
            const deepclone = SON.parse(JSON.stringify(obj))
          </script>

              <script>
                // 异常处理
                // throw 抛异常：用于主动抛出一个异常对象（可以是 Error 及其子类实例，或任意值），
                // function checkAge(age) {
                //     if (age < 18) {
                //         throw new Error("年龄不足 18 岁");
                //     }
                //     return "成年";
                // }
                // checkAge(33)
                // checkAge(1)
                try {
                  // 可能抛出异常的代码
                } catch (error) {
                  // 异常处理逻辑
                  console.log("捕获到异常:", error.message);
                } finally {
                  // 无论是否发生异常都会执行的代码（可选）
                }
                function calculateSum(arr) {
                  let sum = 0;
                  for (let i = 0; i < arr.length; i++) {
                    debugger; // 每次循环都会暂停
                    sum += arr[i];
                  }
                  return sum;
                }

                const result = calculateSum([1, 2, 3, 4]);
                console.log("总和:", result);
                function fetchData(url) {
                  if (!url) {
                    throw new Error("URL 不能为空");
                  }

                  try {
                    // 模拟网络请求
                    if (url === "https://invalid-api.com") {
                      throw new Error("网络请求失败");
                    }

                    const data = { name: "Alice", age: 30 };
                    debugger; // 检查返回的数据
                    return data;
                  } catch (error) {
                    console.log("请求处理失败:", error.message);
                    throw new Error("数据获取失败"); // 重新抛出异常
                  }
                }

                try {
                  const data = fetchData("https://invalid-api.com");
                  console.log("数据:", data);
                } catch (error) {
                  console.log("捕获到外层异常:", error.message);
                  // 显示错误页面或提示用户
                }
              </script>

<script>
  //改变this
  // call()
  // 定义一个对象 obj，包含 uname 属性
  // const obj = { uname: 'pink' };
  // // 定义函数 fn，接收两个参数 x 和 y
  // function fn(x, y) {
  //     // 由于使用 call 方法调用 fn 并将 this 指向 obj，因此这里的 this 指向 obj 对象
  //     console.log(this); // 输出: { uname: 'pink' }

  //     // 计算并输出 x 和 y 的和
  //     console.log(x + y); // 输出: 3 (1 + 2)
  // }
  // 使用 call 方法调用 fn 函数
  // 第一个参数 obj 指定函数内部的 this 指向 obj 对象
  // 后续参数 1 和 2 分别传递给函数的参数 x 和 y
  // apply
  // const obj = { age: 18 };
  // function fn(x, y) {
  //     console.log(this); // {age: 18}
  //     console.log(x + y);
  // }
  // // 1. 调用函数
  // // 2. 改变this指向
  // fn.apply(obj, [1, 2]);
  // 3. 返回值 本身就是在调用函数，所以返回值就是函数的返回值
  // 使用场景：求
  
  // const obj = {
  //     age: 18
  // }
  // function fn() {
  //     console.log(this)
  // }
  // // 1. bind  不会调用函数
  // // 2. 能改变this指向
  // // 3. 返回值是个函数，但是这个函数里面的this是更改过的obj
  // const fun = fn.bind(obj)
  // console.log(fun)
  // // fun()
</script>

<script src='lodash.js'></script>
<script>
  // 防抖（debounce）是一种优化函数执行频率的技术，用于在事件频繁触发时，确保特定函数在规定时间内只执行一次，
  // 避免因过度调用导致性能问题。以下是详细解释：
  // 利用防抖实现性能优化
  // 需求：鼠标在盒子上移动，里面的数字就会变化 + 1
  const box = document.querySelector('.box')
  let i = 1
  function mouseMove() {
    box.innerHTML = i++
    // 如果里面存在大量消耗性能的代码，比如dom操作，比如数据处理，可能造成卡顿
  }
  // 添加事件
  // box.addEventListener('mousemove', mouseMove)

  // 利用Lodash库实现防抖 - 500毫秒之后采取+1
  // 语法: _.debounce(fun, 时间)
  box.addEventListener('mousemove', _.debounce(mouseMove, 500))
</script>

<!-- <script>
  // 防抖（debounce）是一种优化函数执行频率的技术，用于在事件频繁触发时，确保特定函数在规定时间内只执行一次，
  // 避免因过度调用导致性能问题。以下是详细解释：
  // 利用防抖实现性能优化
  // 需求：鼠标在盒子上移动，里面的数字就会变化 + 1
  const box = document.querySelector('.box')
  let i = 1
  function mouseMove() {
    box.innerHTML = i++
    // 如果里面存在大量消耗性能的代码，比如dom操作，比如数据处理，可能造成卡顿
  }
  // 添加事件
  // box.addEventListener('mousemove', mouseMove)

  // 利用Lodash库实现防抖 - 500毫秒之后采取+1
  // 语法: _.debounce(fun, 时间)
  box.addEventListener('mousemove', _.debounce(mouseMove, 500))
</script> -->