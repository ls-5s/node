<!--
    const response = await axios.get('你的接口完整URL', {
      // Query 参数配置，会拼接到 URL 后面，格式如 ?pageId=0
      params: {
        pageId: pageId 
      },
      // Header 参数配置
      headers: {
        platform: platform 
      }
    });

methods: {
  // 获取用户列表
  async getUsers() {
    try {
      const res = await axios.get('/api/users');
      this.users = res.data;
    } catch (error) {
      console.error('获取用户失败', error);
    }
  },
  
  // 创建用户
  async createUser() {
    try {
      await axios.post('/api/users', this.userForm);
      this.getUsers(); // 重新获取列表
      alert('创建成功');
    } catch (error) {
      console.error('创建失败', error);
    }
  },
  
  // 更新用户
  async updateUser() {
    try {
      await axios.put(`/api/users/${this.currentUserId}`, this.userForm);
      this.getUsers();
      alert('更新成功');
    } catch (error) {
      console.error('更新失败', error);
    }
  },
  
  // 删除用户
  async deleteUser(userId) {
    if (confirm('确定删除吗？')) {
      try {
        await axios.delete(`/api/users/${userId}`);
        this.getUsers();
        alert('删除成功');
      } catch (error) {
        console.error('删除失败', error);
      }
    }
  }
}
或者     const response = await axios.delete({
                 url: '/my/article/info',
                 params: {
                     id: articleId
                 },
             })
<head>
    <!-- 确保页面在 IE 浏览器中以最新的渲染模式显示 -->
<!-- <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- 设置页面在移动设备上的视口，宽度与设备宽度一致，初始缩放比例为 1 -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- 页面标题 -->
<title>2.认识URL</title>
</head> -->

<body>


    <!-- 新闻数据地址 -->
    <!-- 新闻数据地址: http://hmajax.itheima.net/api/news -->
    <!-- 引入 Axios 库 -->
    <!-- <p></p>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script>
        发起 HTTP 请求获取新闻数据

        axios({
            url: 'http://hmajax.itheima.net/api/city',
            params: {  // 查询参数  
                pname: '四川省'
            }
        }).then(result => {
            // 请求成功时，将响应结果打印到控制台
            console.log(result.data.list);
            document.querySelector('p').innerHTML = result.data.list.join('<br>')
        }).catch(error => {
            // 请求失败时，将错误信息打印到控制台
            console.error('请求出错:', error);
        }); --> -->

    </script>
</body>

</html> -->
<!-- 请求方法：对服务器资源，要执行的操作
请求方法 操作
GET 获取数据
POST 提交数据
PUT 修改数据（全部）
DELETE 删除数据
PATCH 修改数据（部分）

axios 请求配置
url：请求的 URL 网址
method：请求的方法，GET 可以省略（不区分大小写）
data：提交数据
javascript
axios({
    url: '目标资源地址',
    method: '请求方法',
    data: {
        参数名: 值
        name: 'liu'
    }
}).then((result) => {
    // 对服务器返回的数据做后续处理
})

}).catch((error) => {
// 当axios请求失败时，会进入这个回调函数
// 用于处理请求过程中发生的错误信息，比如网络错误、服务器返回错误状态码等
console.log(error);
});

console.log(result)
}).catch(error => {
// 失败
// 处理错误信息
console.log(error)
console.log(error.response.data.message)
alert(error.response.data.message)
})

HTTP 响应状态码：用来表明请求是否成功完成
状态码 说明
1xx 信息
2xx 成功
3xx 重定向消息
4xx 客户端错误
5xx 服务端错误

// 插件名称：form - serialize 插件
// 插件作用：快速收集表单元素的值
// 使用 serialize 收集数据
const data = serialize(form, {
hash: true, // 返回对象格式 {key: value}
empty: true // 保留空值字段（如输入框未填时值为空字符串）
});(环境没有配置好)
声明文档类型为 HTML5
<body>
    创建一个文件上传输入框，类名为 upload
<!-- <input type="file" class='upload'>
<!-- 创建一个图片元素，用于显示上传后的图片，初始 src 为空 -->
<!-- <img src="" alt=""> -->
<!-- 引入 axios 库，用于发送 HTTP 请求 -->
<!-- <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<script> --> -->
// 为文件上传输入框添加 change 事件监听器，当用户选择文件时触发
// document.querySelector('.upload').addEventListenge', e => {
// // 打印用户选择的第一个文件对象，方便调试查看文件信息
// console.log(e.target.files[0]);

// // 创建一个 FormData 对象，用于将文件数据以表单形式发送到服务器
// const fd = new FormData();

// // 向 FormData 对象中添加一个名为 'img' 的字段，值为用户选择的第一个文件
// fd.append('img', e.target.files[0]);

// // 使用 axios 发送一个 POST 请求到指定的上传图片的 API 接口
// axios({
// // 请求的 URL
// url: 'http://hmajax.itheima.net/api/uploadimg',
// // 请求方法为 POST，用于向服务器提交数据
// method: 'POST',
// // 请求的数据，即包含文件的 FormData 对象
// data: fd
// })
// .then(result => {
// // 当请求成功时，打印服务器返回的结果，方便调试查看返回的数据结构
// console.log(result);

// // 从服务器返回的数据中提取图片的 URL
// const iurl = result.data.data.url;

// // 将提取到的图片 URL 赋值给页面上的 img 元素的 src 属性，从而显示上传后的图片
// document.querySelector('img').src = iurl;
// });
// });
// </script>
// </body>
<!-- 使用 XMLHttpRequest

步骤：

创建 XMLHttpRequest 对象
配置请求方法和请求地址
监听 loaded 事件，接收响应结果
发起请求
示例代码： -->
<!-- 
const xhr = new XMLHttpRequest()
xhr.open('请求方法', '请求url网址')
xhr.addEventListener('loadend', () => {
// 响应结果
console.log(xhr.response)
})
xhr.send() -->
body>
<!-- 创建一个空的段落元素，用于后续显示从服务器获取的数据 -->
<p></p>
<!-- 引入 axios 库，虽然在当前代码中未使用，但可以为后续可能的请求使用做准备 -->
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<script>
    // 通过 document.querySelector 方法获取页面中的第一个 p 元素，并将其赋值给变量 p
    const p = document.querySelector('p');
    // 创建一个 XMLHttpRequest 对象，用于进行异步的 HTTP 请求
    xhr = new XMLHttpRequest();
    // 配置请求方法为 GET，并指定请求的 URL 地址
    // 这里请求的是 http://hmajax.itheima.net/api/province 这个接口
    xhr.open('GET', 'http://hmajax.itheima.net/api/province');
    // 监听 loadend 事件，当请求完成（无论成功还是失败）时触发该事件
    xhr.addEventListener('loadend', () => {
        // 将服务器返回的响应数据输出到控制台，方便调试查看
        console.log(xhr.response);
        // 由于服务器返回的响应数据是 JSON 格式的字符串，使用 JSON.parse 方法将其解析为 JavaScript 对象
        const data = JSON.parse(xhr.response);
        // 将解析后的数据中的 list 数组元素用 <br> 连接成一个字符串，并将其赋值给 p 元素的 innerHTML 属性
        // 这样就可以将数据显示在页面的 p 元素中
        p.innerHTML = data.list.join('<br>');
        // 将连接后的字符串输出到控    看
        console.log(data.list.join('<br>'));
    });
    // 发起请求，将请求发送到服务器
    xhr.send();
</script>
</body>

<body>
    <!-- 创建一个按钮，用户点击该按钮来触发注册操作 -->
    <button>注册用户</button>
    <!-- 引入 axios 库，虽然在当前代码中实际使用的是 XMLHttpRequest，但引入 axios 可能是为后续功能扩展做准备 -->
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script>
        // 使用 querySelector 方法获取页面中的 button 元素，并为其添加点击事件监听器
        document.querySelector('button').addEventListener('click        ', () => {
            // 创建一个 XMLHttpRequest 对象，用于与         
            const xhr = new XMLHttpRequest();
            // 配置请求方法为 POST，并指定请求的 URL 为 "http://hmajax.itheima.net/api/register"
            xhr.open('POST', 'http://hmajax.itheima.net/api/register');
            // 监听 loadend 事件，当请求完成（无论成功还是失败）时触发该事件
            xhr.addEventListener('loadend', () => {
                // 将服务器返回的响应内容输出到控制台，方便调试查看
                console.log(xhr.response);
            });
            // 设置请求头，告诉服务器发送的数据类型是 JSON 字符串
            xhr.setRequestHeader('Content-Type', 'application/json');
            // 创建一个包含用户名和密码的 JavaScript 对象，模拟用户注册信息
            const user = {
                username: 'illiii009',
                password: "1234567"
            };
            // 使用 JSON.stringify 方法将 user 对象转换为 JSON 字符串，以便在 HTTP 请求中发送
            const s = JSON.stringify(user);
            // 发送 HTTP 请求，并将转换后的 JSON 字符串作为请求体发送到服务器
            xhr.send(s);
        });
    </script>
</body>

//什么是Promise 它是表示一个异步的最终状态和结果值的对象
// 为什么要学它Promise 成功和失败的状态可以对应处里
// Promise 的使用步骤
// 1. 创建Promise对象
const p = new Promise((resolve, reject) => {
// 2. 执行异步任务-并传递结果
// 成功调用：resolve(值) 触发 then() 执行
// 失败调用：reject(值) 触发 catch() 执行
})
// 3. 接收结果
p.then(result => {
// 成功
}).catch(error => {
// 失败
})
//Promise的三种状态（状态被接受，没有办法改变）
new Promise() 待定，没有被兑现，也没有被拒绝
resolve() 操作成功
reject() 操作失败

<!-- <body>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script>
        // 使用Promise 管理异步操作
        // 创立Promise
        const p = new Promise((resolve, reject) => {
            // Promise对象创建时，这里的代码都会执行了
            // 2. 执行异步代码
            setTimeout(() => {
                // resolfilled状态-已兑现' => then()
                resolve('模拟AJAX请求-成功结果')
                // reject() => 'rejected状态-已拒绝' => catch()
                // reject(new Error('模拟AJAX请求-失败结果'))
            }, 2000)
        })
        console.log(p)
        // 3. 获取结果
        p.then(result => {
            console.log(result)
        }).catch(error => {
            console.log(error)
        })
    </script>
</body> -->



<body>
    <p></p>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script>
        function myAxios(config) {
            return new Promise((resolve, reject) => {
                // 检查配置对象 config 中是否存在 params 属性
                // 如果存在 params 属性，意味着有查询参数需要处理
                if (config.params) {
                    // 使用 URLSearchParams 构造函数创建一个新的实例 paramsobj
                    // 将 config.params 这个包含查询参数的对象传入，将其转换为 URLSearchParams 对象
                    // 这样便于后续对查询参数进行处理和转换
                    const paramsobj = new URLSearchParams(config.params);
                    // 调用 paramsobj 的 toString 方法
                    // 将 URLSearchParams 对象内部的查询参数转换为符合 URL 规范的字符串
                    // 该字符串格式为键值对用 & 连接，键和值用 = 连接，例如 key1=value1&key2=value2
                    const queryString = paramsobj.toString();
                    // 将生成的查询字符串拼接到 config 对象的 url 属性后面
                    // 使用模板字符串，在查询字符串前添加问号 ?，用于分隔 URL 路径和查询参数
                    // 以此更新 config.url 为带有查询参数的完整 URL
                    config.url += `?${queryString}`;
                }
                const xhr = new XMLHttpRequest()
                xhr.open(config.method || 'GET', config.url)
                xhr.addEventListener('loadend', () => {
                    if (xhr.status >= 200 && xhr.status < 300) {
                        resolve(JSON.parse(xhr.response))
                    } else {
                        reject(new Error(xhr.response))
                    }
                })
                xhr.send()
            })
        }
        myAxios({
            url: 'http://hmajax.itheima.net/api/area',
            params: {
                pname: '辽宁省',
                cname: '大连市'
            }
        }).then(result => {
            console.log(result)
            const p = document.querySelector('p')
            // 将请求结果中的list数组元素用<br>连接成字符串，并设置为p元素的innerHTML
            p.innerHTML = result.list.join('<br>')
        }).catch(Error => {
            // 当请求失败时，执行catch方法中的回调函数
            // 在控制台打印错误对象
            console.dir(Error)
            // 获取页面中第一个p元素
            const p = document.querySelector('p')
            // 将错误信息设置为p元素的innerHTML
            p.innerHTML = Error.message
        })
    </script>
</body>

</html>


重点、、、、、、、、、
if (config.params) {
// 使用 URLSearchParams 构造函数创建一个新的实例 paramsobj
// 将 config.params 这个包含查询参数的对象传入，将其转换为 URLSearchParams 对象
// 这样便于后续对查询参数进行处理和转换
const paramsobj = new URLSearchParams(config.params);
// 调用 paramsobj 的 toString 方法
// 将 URLSearchParams 对象内部的查询参数转换为符合 URL 规范的字符串
// 该字符串格式为键值对用 & 连接，键和值用 = 连接，例如 key1=value1&key2=value2
const queryString = paramsobj.toString();
// 将生成的查询字符串拼接到 config 对象的 url 属性后面
// 使用模板字符串，在查询字符串前添加问号 ?，用于分隔 URL 路径和查询参数
// 以此更新 config.url 为带有查询参数的完整 URL
config.url += `?${queryString}`;
}
// 检查配置对象 config 中是否存在 data 属性
// data 属性通常用于存储请求体数据
if (config.data) {
// 2. 转换数据类型，在 send 中发送
// 使用 JSON.stringify 方法将 config.data 转换为 JSON 字符串
// 这样可以将 JavaScript 对象转换为适合在 HTTP 请求中发送的格式
const jsonStr = JSON.stringify(config.data);
// 设置请求头的 Content-Type 字段为 application/json
// 这告诉服务器请求体的数据格式是 JSON
// 以便服务器能正确解析请求体
xhr.setRequestHeader('Content-Type', 'application/json');
// 调用 XMLHttpRequest 对象的 send 方法发送请求
// 将转换后的 JSON 字符串作为请求体发送到服务器
xhr.send(jsonStr);
} else {
// 如果没有请求体数据，正常的发起请求
// 调用 XMLHttpRequest 对象的 send 方法，不传递任何参数
// 意味着发送一个不带请求体的 HTTP 请求
xhr.send();
}

同步代码：
我们应该注意的是，实际上浏览器是按照我们的书写代码的顺序一行一行地执行程序的。
浏览器会等待代码的解析和工作，在上一行完成后才会执行下一行。这样做是很必要的，
因为每一行的代码都是建立在前面代码的基础之上的。

异步代码：
异步编程技术使你的程序可以在执行一个可能长时间运行的任务的同时继续对其他事件
做出反应而不必等待任务完成。与此同时，你的程序也将在任务完成后显示结果。


Promise 链式调用new Promise() --->
.then(回调函数) ---> 新的Promise()对象
|
|____________________|
回调函数return结构
这个可以解决回调函数的嵌套问题
<script>
    // 创建一个Promise对象p，模拟异步获取省份数据
    // const p = new Promise((resolve, reject) => {
    //     // 2秒后返回省份名称
    //     setTimeout(() => {
    //         resolve('北京市')
    //     }, 2000)
    // })

    // 链式调用：处理省份数据并获取对应的城市数据
    const p2 = p.then(result => {
        // 打印获取到的省份名称
        console.log(result)

        // 返回一个新的Promise，模拟根据省份获取城市数据的异步操作
        return new Promise((resolve, reject) => {
            // 再经过2秒后返回拼接了城市信息的结果
            setTimeout(() => {
                resolve(result + '---北京')
            }, 2000)
        })
    })

    // 继续链式调用：处理城市数据并获取对应的地区数据
    p2.then(result => {
        // 打印获取到的城市信息
        console.log(result)
    })
</script>
<script>

    let pname = ''
    // 1. 得到-获取省份Promise对象
    axios({ url: 'http://hmajax.itheima.net/api/province' }).then(result => {
        pname = result.data.list[0]
        document.querySelector('.province').innerHTML = pname
        // 2. 得到-获取城市Promise对象
        return axios({ url: 'http://hmajax.itheima.net/api/city', params: { pname } })
    }).then(result => {
        const cname = result.data.list[0]
        document.querySelector('.city').innerHTML = cname
        // 3. 得到-获取地区Promise对象
        return axios({ url: 'http://hmajax.itheima.net/api/area', params: { pname, cname } })
    }).then(result => {
        console.log(result)
        const areaName = result.data.list[0]
        document.querySelector('.area').innerHTML = areaName
    })

</script>

<script>
    // async 函数
    // 它是声明异步函数，任何在函数定义前加上async关键字的函数，都成为异步函数。
    // 异步函数会自动返回一个Promise对象。
    async function f() {
        // 函数体，可包含异步操作
    }
    // 如果异步函数中没有return语句，或者return一个非Promise的值，那么返回的Promise会以该值（或undefined）被resolved。
    // 如果return一个Promise对象，那么返回的Promise会跟随这个被返回的Promise的状态。
    // 若函数内部抛出错误，返回的Promise会被rejected。
    // 例如：
    async function simpleAsyncFunction() {
        return 42; // 返回值会使返回的Promise以42被resolved
    }
    simpleAsyncFunction().then(result => {
        console.log(result); // 输出42
    });
    // await只能在async函数内部使用，用于暂停异步函数的执行，等待一个Promise对象的解决（resolved）或拒绝（rejected）。
    // 它会 “阻塞” 代码的执行，直到所等待的Promise完成。

    async function asyncFunction() {
        let result = await somePromise; // 等待Promise完成
        // 后续代码
    }
    // 当await一个被resolved的Promise时，await表达式会返回该Promise的解决值。
    // 当await一个被rejected的Promise时，会抛出错误，需要使用try...catch语句来捕获处理。
    function delayPromise() {
        return new Promise((resolve) => {
            setTimeout(() => resolve('延迟完成'), 1000);
        });
    }
    async function useAwait() {
        try {
            let result = await delayPromise();
            console.log(result); // 输出'延迟完成'
        } catch (error) {
            console.error(error);
        }
    }
    useAwait();

</script>

<script>
    try {
        async function f() {
            const pObj = await axios({ url: 'http://hmajax.itheima.net/api/province' })
            console.log(pObj)
            const pname = pObj.data.list[0]
            const cObj = await axios({ url: 'http://hmajax.itheima.net/api/city', params: { pname } })
            console.log(cObj)
            const cname = cObj.data.list[0]
            const aObj = await axios({ url: 'http://hmajax.itheima.net/api/area', params: { pname, cname } })
            const areaName = aObj.data.list[0]
            console.log(areaName)
            document.querySelector('.province').innerHTML = pname
            document.querySelector('.city').innerHTML = cname
            document.querySelector('.area').innerHTML = areaName
        }
        f()
    } catch (error) {
        console.dir(error)
    }

</script>
</body>
<script>
    // 事件循环
    // 执行代码和收集异步任务，在调用栈空闲时，反复调用任务队列里面的回调函数
    // jS 在某一刻只能执行一行代码，为了让耗时代码不阻塞其他代码运行，才设计了事件循环
    console.log(1);
    setTimeout(() => {
        console.log(2);
    }, 0);
    console.log(3);
    setTimeout(() => {
        console.log(4);
    }, 2000);
    console.log(5);
    //         执行同步代码：
    //         console.log(1) 直接执行，输出 1。
    // 遇到 setTimeout(() => { console.log(2); }, 0)，这是 宏任务，将其回调加入浏览器的宏任务队列（定时器队列），但不立即执行。
    // 继续执行 console.log(3)，输出 3。
    // 遇到 setTimeout(() => { console.log(4); }, 2000)，同样是 宏任务，将其回调加入宏任务队列（定时器队列），因延迟 2000ms，需等待计时结束。
    // 执行 console.log(5)，输出 5。
    //         处理宏任务队列：
    //         同步代码执行完毕，调用栈为空。此时检查微任务队列（本例无徽任务），然后从宏任务队列中取第一个任务（第一个 setTimeout 回调）。
    // 执行 console.log(2)，输出 2（第一个 setTimeout 延迟 0，优先执行）。
    // 等待 2000ms 后，第二个 setTimeout 计时结束，取出其回调执行 console.log(4)，输出 4。
    //         最终控制台输出顺序为：1 3 5 2 4，完全符合事件循环 “先同步，再宏任务（按规则排队）” 的执行逻辑。

    // 宏任务和微任务
    //宏任务：浏览器环境执行异步代码
    // JS脚本执行事件(script)
    // setTimeout / setInterval
    // AJAX请求完成事件
    // 用户交互事件等
    // // 微任务:js引擎环境执行的异步代码
    // Promise对象.then() 注 Promise 本身是同步的, 而then和catch回调函数是异步
    // 同步优先：同步代码永远先于异步代码执行。
    // 微任务插队：每个宏任务执行前，微任务队列会被清空（即使执行过程中新增微任务）。
    // 宏任务按序执行：宏任务按注册顺序（如定时器超时时间）依次执行，但需等待当前微任务队列清空。

</script>

<script>
    // Promise.all静态方法
    // 合并多个Promise对象, s等待所有同时成功完成(或者一个失败), 做后续逻辑
    const a = axios({ url: 'http://hmajax.itheima.net/api/weather', params: { city: '110100' } })
    const b = axios({ url: 'http://hmajax.itheima.net/api/weather', params: { city: '110100' } })
    const c = axios({ url: 'http://hmajax.itheima.net/api/weather', params: { city: '110100' } })
    const d = axios({ url: 'http://hmajax.itheima.net/api/weather', params: { city: '110100' } })
    // const p = Promise.all([a, b, c, d])
    p.then(result => {
        console.log(result)
        const s = result.map((item) => {
            return `<li>${item.data.data.area} --- ${item.data.data.weather}</li>`
        }).join('')
        console.log(s)
        document.querySelector('ul').innerHTML = s
    }).catch(error => {
        console.dir(error)
    })
</script>